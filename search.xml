<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>踩坑小记——CSS Table 布局</title>
      <link href="2021/08/cai-keng-xiao-ji-css-table/"/>
      <url>2021/08/cai-keng-xiao-ji-css-table/</url>
      
        <content type="html"><![CDATA[<h2 id="tldr"><a class="markdownIt-Anchor" href="#tldr"></a> TL;DR</h2><blockquote><p><code>&lt;table&gt;</code> 标签指定了 <code>height</code> 样式之后，假如总高度不足表格高度，每一行将会等分这个值。</p></blockquote><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近开发过程中使用了一个表格组件，该组件使用 <code>&lt;table&gt;</code> 标签实现，主要用于大量数据的展示，因此自然需要指定高度并且支持滚动。</p><p>样式调整妥当后，试着给了两行数据，发现严重跑版，如下图：</p><p><img src="https://i.loli.net/2021/08/10/1fRmBbTos2pH8MQ.png" alt="#b# 只出现两行数据时渲染出现问题" /></p><p>预期第一列为复选框，支持选中当前行，第二列为展示的数据。检查细节如下（信息已脱敏）：</p><p><img src="https://i.loli.net/2021/08/10/Lj4qXAJ71irNP9f.png" alt="#b# 第一列呈现居中" /></p><p><img src="https://i.loli.net/2021/08/10/kQyb2VaqgUBOuos.png" alt="#b# 第二列却未居中" /></p><h2 id="抛砖引玉"><a class="markdownIt-Anchor" href="#抛砖引玉"></a> 抛砖引玉</h2><h3 id="云山雾罩"><a class="markdownIt-Anchor" href="#云山雾罩"></a> 云山雾罩</h3><p>尝试了多行数据，发现情况类似，都是等分了高度。总结一下，主要存在以下两个问题：</p><ol><li>指定表格高度，固定为 266，行高 38，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>266</mn><mo>=</mo><mn>38</mn><mo>×</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">266 = 38 \times 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>，呈现 7 行，只有两行时却等分了表格高度；</li><li>两列的 class 都相同，理应呈现相同的样式，为何第二列没有等分；</li></ol><p>首先猜测 <code>&lt;table&gt;</code> 有等分行高的 CSS 属性，使用某个属性可以关闭，搜了半天没有结果。打算从以下几个方面入手：</p><ul><li><code>&lt;table&gt;</code> 有特定 HTML 属性可以控制该效果（表格布局有一系列元素，但平常使用不多），找到该属性</li><li>某个层级的隐藏 CSS 属性触发了该效果，找到该属性</li><li>尝试其他布局方式 <s>（<code>display</code> 一个一个试）</s></li><li>重写表格渲染的逻辑，使用 <code>&lt;div&gt;</code> 一把梭</li></ul><h3 id="峰回路转"><a class="markdownIt-Anchor" href="#峰回路转"></a> 峰回路转</h3><p>经过一系列挣扎，突然发现取消 <code>&lt;table&gt;</code> 的 <code>height</code> 属性即可恢复 😅。开发的问题是解决了，可是为什么会这样呢？</p><ol><li>什么原理导致加了 <code>height</code> 属性就会产生这种效果？</li><li>为什么只等分了第一列？</li></ol><p>最初的猜测其实是较为合理的：</p><ol><li>等分表格的总高度在某些场景下可美化布局</li><li>第一列的表格语义上一般作为编号，居中更合理，其余行的样式由用户定义</li></ol><p>但奇怪的是这种特性在搜索结果中，没有反映出来（可能是我关键词不对），<s>况且浪费了将近一天时间，不能就这样草草结束</s>，所以非得找个说法才行。</p><h3 id="柳暗花明"><a class="markdownIt-Anchor" href="#柳暗花明"></a> 柳暗花明</h3><p>首先能想到比较权威的文档就是 <a href="https://developer.mozilla.org/">MDN</a> 了。找遍了 HTML <code>&lt;table&gt;</code> 和 CSS table 模块，没有相关描述。突然想到有个 《CSS 权威指南》（下称 《指南》），也许会有记录，果不出所料：</p><p><img src="https://i.loli.net/2021/08/10/STHd1trDZepb7nA.png" alt="#b# 《CSS 权威指南（第三版）》对表格高度的描述" /></p><p>如上图，用户代理（User-Agent）在这里起了不可替代的作用，于是写了一个 demo（见 <a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a>），尝试了 Firefox、Safari、Chrome 和 Edge 下的表现，效果相同。</p><p>《指南》听名字就很权威，但我还是不够满足，在  <a href="https://github.com/Xiaoleng123">xileng</a> 的指导下，想起来还有 <a href="https://www.w3.org/">W3C</a> 的存在，这里应该能找到我要的标准和规范了。</p><p>在海量的文献里，最终定位到了问题：</p><p><img src="https://i.loli.net/2021/08/10/EORTDMLZWavSpKd.png" alt="#b# CSS 3 草案关于 table height 的描述" /></p><p>如上图（原文 <a href="https://www.w3.org/TR/2019/WD-css-tables-3-20190727/#height-distribution">在此</a>），印证了《指南》中的描述。</p><h2 id="表格元素"><a class="markdownIt-Anchor" href="#表格元素"></a> 表格元素</h2><p>HTML 中关于表格有一系列元素，参见 <a href="https://wangdoc.com/html/table.html">表格标签 - 网道</a>。</p><ul><li><p>定义大纲</p><ul><li><code>&lt;table&gt;</code>：<strong>块级</strong> 容器元素，承载所有内容</li><li><code>&lt;caption&gt;</code>：可选。是 <code>&lt;table&gt;</code> 标签第一个子元素，表示表格的标题</li></ul></li><li><p>定义结构：有以下元素，都是块级容器元素，且都是 <code>&lt;table&gt;</code> 的一级子元素</p><ul><li><code>&lt;thead&gt;</code>：表头</li><li><code>&lt;tbody&gt;</code>：表体。可使用多个 <code>&lt;tbody&gt;</code>，表示连续的多个部分</li><li><code>&lt;tfoot&gt;</code>：表尾</li></ul></li><li><p>定义行列</p><ul><li><code>&lt;colgroup&gt;</code>：<code>&lt;table&gt;</code> 的一级子元素，定义行</li><li><code>&lt;col&gt;</code>：<code>&lt;colgroup&gt;</code> 的一级子元素，定义列。单独使用，没有结束标签，且 不含子元素</li></ul>  <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>colgroup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>c1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>c2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>c3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>colgroup</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为每一列指定 class</p></li><li><p>表示行列</p><ul><li><code>&lt;tr&gt;</code>：表格的一行</li><li><code>&lt;th&gt;</code>：标题单元格</li><li><code>&lt;td&gt;</code>：数据单元格</li></ul>  <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>学号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>001<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>002<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>李四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="表格样式"><a class="markdownIt-Anchor" href="#表格样式"></a> 表格样式</h2><p><img src="https://i.loli.net/2021/08/10/H9KhstuyMorWj1D.png" alt="#b# 表格的用户代理样式" /></p><p>观察一下默认样式，有以下几个不熟悉：</p><ul><li><code>border-collapse</code>：决定表格的边框是分开还是合并<ul><li><code>collapse</code>：共用边框</li><li><code>separate</code>：每个单元格独立边框</li></ul></li><li><code>border-spacing</code>：指定相邻单元格之间的距离，因此只适用于 <code>border-collapse: separate;</code><ul><li>相当于 HTML 的 <code>cellspacing</code> 属性</li><li>可分别指定水平和垂直：<code>border-spacing: 1px 2px;</code></li></ul></li></ul><h2 id="display-布局"><a class="markdownIt-Anchor" href="#display-布局"></a> <code>display</code> 布局</h2><p>至此，第一个 <a href="#%E4%BA%91%E5%B1%B1%E9%9B%BE%E7%BD%A9">问题</a> 解决了，但第二个问题还没见到原因。说来奇怪，调试的时候突然发现第二列写了 flex 布局，该属性来自组件库，取消后就居中了 😅。那么问题又来了：为什么 flex 可以不按上述规定？</p><p>其实很好笼统地解释：布局使然，<code>table</code>、<code>flex</code>、<code>inline-table</code> 效果不尽相同，之前尝试 <code>inline</code> 以及 <code>inline-block</code> 可以绕道解决问题，所以才产生重写布局的想法，然而 CSS 基础太差了，这些布局一知半解。借此机会整理一下。</p><h3 id="全局属性值"><a class="markdownIt-Anchor" href="#全局属性值"></a> 全局属性值</h3><ul><li><code>inherit</code>：从父元素继承属性的值</li><li><code>initial</code>：恢复元素属性的默认值（默认值由 CSS 规范定义，而非用户代理）</li><li><code>unset</code>：<ul><li>如果父类有值，则从父类继承，类似 <code>inherit</code></li><li>否则，设为初始值，类似 <code>initial</code></li></ul></li><li><code>revert</code>：类似 <code>unset</code> <em>CSS Cascading 3</em><ul><li>恢复到用户代理或用户创建的自定义样式表设置的值</li></ul></li></ul><h3 id="上下文"><a class="markdownIt-Anchor" href="#上下文"></a> 上下文</h3><ul><li><code>none</code>：元素将从文档流中移除，不会显示</li><li><code>block</code>：块级元素<ul><li>独占一行，后面的元素新起一行，默认填满父元素宽度</li><li>高度一般以子元素撑开的高度为准</li><li>可设置 <code>width</code>/<code>height</code>，<code>margin</code> 和 <code>padding</code></li></ul></li><li><code>inline</code>：内联元素<ul><li>在同一行，直到排满换行</li><li><code>width</code>/<code>height</code> 无效</li><li><code>margin</code> 和 <code>padding</code> 有效，但 <code>-top</code>、<code>-bottom</code> 无效</li></ul></li><li><code>inline-block</code>：结合 <code>block</code> 和 <code>inline</code><ul><li>在同一行内，但内容有块级元素的效果</li><li><code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code> 都有效</li></ul></li><li><code>list-item</code>：将元素作为列表显示，借助 <code>list-style-position</code>、<code>list-style-type</code> 可模拟 <code>&lt;li&gt;</code> 效果</li><li><code>flex</code>：具体布局技术不说了，规范见 <a href="https://www.w3.org/TR/css-flexbox-1">CSS Flexbox 1</a><blockquote><p>在本文中，第二列指定了高度，并且设置了 flex，遵循 <a href="https://www.w3.org/TR/css-flexbox-1/#box-model">规定</a>，flexbox 取指定的值</p></blockquote></li><li><code>inline-flex</code>：没有指定宽度时，<code>flex</code> 会填充父容器，<code>inline-flex</code> 不会</li></ul><h3 id="表格相关"><a class="markdownIt-Anchor" href="#表格相关"></a> 表格相关</h3><ul><li><code>table</code>：作为块级表格来显示（类似 <code>&lt;table&gt;</code>）</li><li><code>inline-table</code>：会作为内联表格来显示（类似 <code>&lt;table&gt;</code>）</li><li><code>table-row</code>：会作为一个表格行显示（类似 <code>&lt;tr&gt;</code>）</li><li><code>table-cell</code>：会作为一个表格单元格显示（类似 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>）</li></ul><h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2><ul><li><a href="https://www.w3.org/TR/">W3C Standards and Drafts</a></li><li><a href="https://html.spec.whatwg.org/">HTML Standard</a>。本文细节出自 <a href="https://www.w3.org/TR/2019/WD-css-tables-3-20190727/">CSS table 3</a></li></ul><h2 id="附录示例代码"><a class="markdownIt-Anchor" href="#附录示例代码"></a> 附录：示例代码</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Table Height demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>colgroup</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>colgroup</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>content-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>content-3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">table</span> <span class="token punctuation">&#123;</span>      <span class="token property">height</span><span class="token punctuation">:</span> 226px<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">tr</span> <span class="token punctuation">&#123;</span>      <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">tr:hover</span> <span class="token punctuation">&#123;</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.04<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">td</span> <span class="token punctuation">&#123;</span>      <span class="token property">height</span><span class="token punctuation">:</span> 38px<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 时光穿梭</title>
      <link href="2020/12/git-shi-guang-chuan-suo/"/>
      <url>2020/12/git-shi-guang-chuan-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>曾经在 <a href="https://github.com/">GitHub</a> 看到一个仓库，是某版 Unix 的历史归档，提交日期是上个世纪。项目具体名称和时间记不清了，在写作本文时我找了很久，只找到一个疑似 <a href="https://github.com/qrush/unix">项目</a>，如下图所示，其提交时间为 13 years ago，即 2008 年，正好是 GitHub 刚上线的时候，或许前段时间 GitHub 有过调整，早于这个时间的项目都以 2008 年计。</p><p><img src="https://i.loli.net/2021/04/05/dmfZCLjre8t7zyR.png" alt="#b# UNIX 项目主页" /></p><p>不过怎样，在 2021 年看到几十年前的项目着实令人震撼，这是怎么做到的？</p><p>首先能想到，文件的时间是属性信息的一种，由文件系统赋予。</p><h2 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性"></a> 文件属性</h2><p>在 UNIX 环境下，文件具有以下时间属性：</p><ul><li><code>atime</code>：access time，最后一次读取文件的时间</li><li><code>mtime</code>：modify time，最后一次文件内容更改的时间</li><li><code>ctime</code>：change time，最后一次文件属性更改的时间</li></ul><p>文件操作会产生如下影响：</p><ul><li>读取文件时，<code>atime</code> 改变</li><li>修改文件属性时，<code>ctime</code> 改变</li><li>修改文件内容时，<code>atime</code>、<code>mtime</code>、<code>ctime</code> 都会改变</li><li>more、less、cat、nl、tail、tac 等命令会更新 <code>atime</code></li><li>ls、stat 不会更新文件的 <code>atime</code></li><li>cmod、chown 修改文件属性，会更新 <code>ctime</code></li><li>touch 都会更改</li></ul><h3 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h3><p>使用 stat 命令可查看以上时间信息。需注意，在 macOS 环境，stat 命令需要加 <code>-x</code> 选项。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ history-repo git:<span class="token punctuation">(</span>master<span class="token punctuation">)</span> ✗ <span class="token function">stat</span> -x README.md-F  -- append <span class="token function">file</span> <span class="token builtin class-name">type</span> indicators <span class="token punctuation">(</span>implies -l<span class="token punctuation">)</span>-L  -- dereference symbolic links-f  -- display per the specified <span class="token function">format</span> string-l  -- display <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> -lT<span class="token variable">`</span></span> <span class="token function">format</span>-n  -- suppress terminating newlines-q  -- suppress error messages about lstat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>/stat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> failure-r  -- display <span class="token keyword">in</span> raw <span class="token punctuation">(</span>numerical<span class="token punctuation">)</span> <span class="token function">format</span>-s  -- display <span class="token keyword">in</span> shell variable-assignment <span class="token function">format</span>-t  -- specify strftime<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token function">format</span> string-x  -- display <span class="token keyword">in</span> verbose <span class="token punctuation">(</span>Linux-style<span class="token punctuation">)</span> <span class="token function">format</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改时间戳"><a class="markdownIt-Anchor" href="#修改时间戳"></a> 修改时间戳</h3><p>很早以前就知道 touch 不仅可以创建文件，还能修改时间戳，一直都没试过，~~反正平常也用不着，~~用法如下：</p><p><img src="https://i.loli.net/2021/04/05/3FfiCSuXW8tMKnp.png" alt="#b# touch 命令的提示" /></p><p>使用 <code>-r</code> 选项可以将文件的时间更改为指定文件的时间，需注意 <code>-r &lt;ref_file&gt;</code> 是一组选项+参数，其后才是要更改的文件，过程如下图：</p><p><img src="https://i.loli.net/2021/04/05/KxZqCBbi1Rr2epY.png" alt="#b# touch 更改时间戳" /></p><p>除此之外，还能自行指定时间，格式为 <code>[[CC]YY]MMDDhhmm[.SS]</code>，因此，在本地文件系统上，文件时间可被自由更改。</p><h2 id="git-提交"><a class="markdownIt-Anchor" href="#git-提交"></a> Git 提交</h2><h3 id="-date-选项"><a class="markdownIt-Anchor" href="#-date-选项"></a> <code>--date</code> 选项</h3><p>Git 在 <code>commit</code> 时，默认会将当前系统时间作为时间戳，可使用 <code>--date=</code> 选项覆盖，详细文档 <a href="https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---dateltdategt">在此</a>。</p><p><img src="https://i.loli.net/2021/04/05/9VPvwZNgBDo6CXx.png" alt="#b# 伪造一个历史提交" /></p><p>可以看到，date 为 1975 年。</p><h3 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h3><blockquote><p>Git 总是在一个 bash shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。</p></blockquote><p>除了指定选项和参数，还可使用环境变量来指定更改时间和提交时间，Git <a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">文档</a> 描述如下：</p><blockquote><p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p><p><code>GIT_AUTHOR_NAME</code> 是 “author” 字段的可读名字。<br /><code>GIT_AUTHOR_EMAIL</code> 是 “author” 字段的邮件。<br /><code>GIT_AUTHOR_DATE</code> 是 “author” 字段的时间戳。<br /><code>GIT_COMMITTER_NAME</code> 是 “committer” 字段的可读名字。<br /><code>GIT_COMMITTER_EMAIL</code> 是 “committer” 字段的邮件。<br /><code>GIT_COMMITTER_DATE</code> 是 “committer” 字段的时间戳。</p><p>如果 <code>user.email</code> 没有配置， 就会用到 <code>EMAIL</code> 指定的邮件地址。 如果 <strong>这个</strong> 也没有设置， Git 继续回退使用系统用户和主机名。</p></blockquote><p>示例命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">GIT_AUTHOR_DATE</span><span class="token operator">=</span><span class="token string">"2031-01-01 12:33:08"</span> <span class="token punctuation">\</span>    <span class="token assign-left variable">GIT_COMMITTER_DATE</span><span class="token operator">=</span><span class="token string">"2031-02-01 12:33:08"</span> <span class="token punctuation">\</span>    <span class="token function">git</span> commit <span class="token builtin class-name">.</span> <span class="token punctuation">\</span>    -m <span class="token string">"some commit message"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在将仓库上传到 GitHub，时间依然显示为当前时间：</p><p><img src="https://i.loli.net/2021/04/05/PdNThkvgbJAQIaM.png" alt="#b# 项目主页的时间" /></p><p>但是打开个人 Profile 会发现 Activity 年份一直到 1975 年：</p><p><img src="https://i.loli.net/2021/04/05/GBUmdC48ciejQx1.png" alt="#b# 历史" /></p><p>GitHub 大抵确乎是改变了显示方式，按照上传时间来显示，但提交时间属于 Git 仓库的信息，依然被保留。</p><p>既然能够控制提交时的时间，那能否修改已提交版本的时间呢？</p><h2 id="修改上一次提交"><a class="markdownIt-Anchor" href="#修改上一次提交"></a> 修改上一次提交</h2><p>修改已提交的内容使用 <code>--amand</code> 选项，使用 <code>-C --reuse-message</code> 重用某一次历史提交及其信息，当然也可以手动输入 <code>author</code>、<code>date</code> 等每一个字段。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit -C c95bed7 --amend --date<span class="token operator">=</span><span class="token string">"2019-01-01 23:12:01"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 <code>-C</code> 参数，Git <a href="https://git-scm.com/docs/git-commit#Documentation/git-commit.txt--cltcommitgt">文档</a> 描述如下：</p><blockquote><p>-C <commit><br />–reuse-message=<commit><br />Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.</p></blockquote><blockquote><p>-c <commit><br />–reedit-message=<commit><br />Like -C, but with -c the editor is invoked, so that the user can further edit the commit message.</p></blockquote><p>注意，这种方式只能修改上一次提交了的信息，对于已被覆盖的历史版本，需要使用 <code>rebase</code> 子命令。</p><h2 id="修改历史提交"><a class="markdownIt-Anchor" href="#修改历史提交"></a> 修改历史提交</h2><blockquote><p>Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。</p></blockquote><p>变基首先要界定修改范围，假设有以下几次提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">commit 1ce2760811ffd5fdc37a841ce9b39198dec4c8b7 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>Date:   Thu Jan <span class="token number">1</span> <span class="token number">23</span>:12:01 <span class="token number">2099</span> +0800    third commitcommit 65d1c641337c79137f73ca4d1a76fed83c467d32Date:   Tue Jan <span class="token number">1</span> <span class="token number">23</span>:12:01 <span class="token number">2019</span> +0800    second commitcommit c95bed78bd36a7e1f4bb4ca1270e8b0791d9f864Date:   Fri Dec <span class="token number">5</span> <span class="token number">12</span>:23:23 <span class="token number">1975</span> +0800    first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要修改 <code>second commit</code> 的内容，就得回到 <code>65d1c641337</code> <strong>之前一次</strong> 提交，即：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reabse -i 65d1c641337^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令表示对 <code>7075919</code> 到 <code>HEAD</code> 之间的提交进行 rebase，<code>-i --interactive</code> 交互式变基。</p><p><img src="https://i.loli.net/2021/04/05/HwRum6GSh7btCZc.png" alt="#b# 进入交互式变基引导界面" /></p><p>可以看到，从上到下依次为历史提交，在 <code>c95bed7</code> 的基础上（onto）。此时，在需要修改的提交前，将 <code>pick</code> 改为 <code>edit</code>，保存退出，将会收到以下提示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Stopped at 65d1c64<span class="token punctuation">..</span>.  second commitYou can amend the commit now, with  <span class="token function">git</span> commit --amendOnce you are satisfied with your changes, run  <span class="token function">git</span> rebase --continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在就类似 <a href="#%E4%BF%AE%E6%94%B9%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">修改上一次提交</a>，可以更改文件，使用 <code>git commit --amend</code> 更改提交，提交之后使用 <code>git rebase --continue</code> 进入下一个标记为 <code>edit</code> 的提交，假如没有冲突且全部更改完成，将成功退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ history-repo git:<span class="token punctuation">(</span>ae2a4c8<span class="token punctuation">)</span> ✗ <span class="token function">git</span> commit --amend -m <span class="token string">"commit from rebase"</span><span class="token punctuation">[</span>detached HEAD 5e8e09e<span class="token punctuation">]</span> commit from rebase Date: Thu Jan <span class="token number">1</span> <span class="token number">23</span>:12:01 <span class="token number">2099</span> +0800 <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>➜ history-repo git:<span class="token punctuation">(</span>5e8e09e<span class="token punctuation">)</span> ✗ <span class="token function">git</span> rebase --continueSuccessfully rebased and updated refs/heads/master.➜ history-repo git:<span class="token punctuation">(</span>master<span class="token punctuation">)</span> ✗<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时查看 log，会发现 commit 信息已被修改，且 Hash 也 <strong>重新计算</strong>（Zsh 的命令提示符发生了变化）。改变历史，注定会影响现在，至少在 Git 系统中是如此处理的。</p><p>不难预见，在团队协作时，单个仓库内版本历史变更后，其他同步版本库的历史状态都会受到影响，在使用变基时需要各自协调好。关于 <code>rebase</code> 的文档 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">在此</a>，最后提醒：慎用 <code>rebase</code>。</p><h2 id="面子工程"><a class="markdownIt-Anchor" href="#面子工程"></a> 面子工程</h2><p>掌握了 Git 的时间密码，现在就可以实现 GitHub 打卡了，写个脚本自动刷小绿点<br />，要多少有多少（逃</p><p><img src="https://i.loli.net/2021/04/05/2PCbxRENKgFWyhM.png" alt="#b# GitHub 打卡" /></p><p>显然这是名副其实的面子工程，全年 365 天不休息并不是什么好习惯，强如 Linus 也有不工作的时间~~，如果不休假，就不会诞生 Git 了（逃~~</p><p>最后敬告：</p><blockquote><p>打铁还需自身硬，评价永远都是基于客观因素，不能只惦记光鲜亮丽的外表。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的生产力工具</title>
      <link href="2020/06/wo-de-sheng-chan-li-gong-ju/"/>
      <url>2020/06/wo-de-sheng-chan-li-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>逛博客的时候，能看到不少博主列出经常使用的软件工具，再者，有不少自媒体如少数派、异次元软件世界等网站时常分享好用的效率工具，知乎也有类似问题如下：</p><ul><li><a href="https://www.zhihu.com/question/37524914">你知道哪些冷门但逆天的 App？</a></li><li><a href="https://www.zhihu.com/question/36546814">有哪些堪称「神器」，却鲜为人知的软件/网站/互联网服务？</a></li><li><a href="https://www.zhihu.com/question/271740133">在当下（2018）使用 iPad 有哪些值得推荐的应用？</a></li></ul><p>知道这些软件并且能够灵活使用，形成自己的工作流，必将提高工作效率和生活质量。</p><p>此前我也记录使用到的工具，使用 TXT 文本或者 Microsoft Todo <s>效率工具用歪了</s>，但清单式的记录方式无法体现每个工具的作用，遂直接列举成文，分享出来，不定期更新。</p><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><h3 id="日常向"><a class="markdownIt-Anchor" href="#日常向"></a> 日常向</h3><ul><li>办公<ul><li>Microsoft Office</li><li>Keynotes</li><li>Pages</li></ul></li><li>浏览器<ul><li>Microsoft Edge：日常使用</li><li>Mozilla Firefox：开发的时候调试页面</li><li>Google Chrome：开发的时候集成测试</li><li>Safari：截图、测试</li></ul></li><li>影音<ul><li>QQ 音乐</li><li>网易云音乐</li><li>IINA</li><li>人人影视</li><li>ZY Player</li></ul></li><li>迅雷</li><li>有道词典</li><li>搜狗输入法</li><li>XMind<ul><li>头脑风暴</li><li>以及学习总结时梳理知识点</li><li>完整版需 <strong>付费</strong></li></ul></li><li>Adobe XD<ul><li>原型设计</li><li>UI 设计</li></ul></li><li>Microsoft ToDo</li><li>Filqlo：屏保，数字时钟</li><li><a href="https://ezip.awehunt.com/">eZip</a>：压缩软件，同类还有：<ul><li>The Unarchiver</li><li><a href="https://www.keka.io/">Keka</a>，免费，但 <em>Mac App Store</em> <strong>收费</strong></li></ul></li><li>AppCleaner：卸载软件</li><li>Tencent Lemon：清理系统，同类产品有：<ul><li>CleanMyMac</li><li><a href="http://www.piriform.com/ccleaner">CCleaner</a></li></ul></li></ul><h3 id="效率向"><a class="markdownIt-Anchor" href="#效率向"></a> 效率向</h3><ul><li><em>Alfred</em>：效率工具，同类有：<ul><li><a href="https://cerebroapp.com/">cerebroapp</a>：开源，跨平台，Electron 技术栈，有插件市场</li><li><a href="https://github.com/qdore/Mutate">Mutate</a>：Linux 平台</li><li><a href="https://github.com/albertlauncher/albert">Albert</a>：Linux 平台</li></ul></li><li>Mounty：NTFS 挂载工具</li><li><a href="https://cloudmounter.net/">CloudMounter</a><br /><img src="https://cloudmounter.net/images/upload/products/clm/screens/wizardScreen3.jpg" alt="CloudMounter 截图来自官网" /><ul><li>OneDrive、DropBox 等网盘挂载工具</li><li>类似 iCloud 的体验</li><li>完整版需 <strong>付费</strong></li></ul></li><li>HyperSwitch<ul><li>窗口切换工具，默认只能切换应用组，而搭配该软件可切换每个窗口，类似 Windows</li></ul></li><li>Reeder 4：macOS/iOS，RSS 阅读器，支持多种 RSS 服务，开源免费同类产品有：<ul><li>Fluent Reader<ul><li>跨平台</li><li>Fluent Design</li><li>Electron + React</li></ul></li><li><a href="https://ranchero.com/netnewswire/">NetWireReader</a><ul><li>macOS/iOS</li><li>Swift 开发</li></ul></li><li>FeedMe<ul><li>Android</li><li>Material Design</li><li>支持多种 RSS 服务</li></ul></li></ul></li><li>CheatSheet：快捷键小抄，显示当前窗口的快捷键</li></ul><h3 id="开发向"><a class="markdownIt-Anchor" href="#开发向"></a> 开发向</h3><ul><li>语言环境<ul><li>系统默认<ul><li>Perl 5</li><li>PHP 7</li><li>Python 2</li><li>Ruby</li><li>Lua</li></ul></li><li>Node.js、Yarn</li><li>Clang/Clang++</li><li><a href="https://www.python.org/">Python 3</a></li><li><a href="https://www.rust-lang.org/">Rust</a></li><li>Java</li><li><a href="https://golang.org/">Go</a></li><li><a href="https://dart.dev/">Dart</a></li></ul></li><li>编辑器<ul><li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li><li><a href="http://www.sublimetext.com/">Sublime Text 3</a></li><li>Vim 8</li></ul></li><li>DBMS<ul><li><a href="https://robomongo.org/">Studio 3T</a><br /><img src="https://robomongo.org/static/screens-transparent-6e2a44fd.png" alt="Studio 3T 截图来自官网" /></li><li><a href="https://sequelpro.com/">Sequal Pro</a><br /><img src="https://sequelpro.com/images/query.png" alt="Sequal Pro 截图来自官网" /></li><li><a href="https://www.beekeeperstudio.io/">Beekeeper Studio</a><br /><img src="https://www.beekeeperstudio.io/assets/img/screenshots/view-dark-07e9bb4fcda1665114ffdfcb62a5e66108feebd18e0949006c219920bf12e25c.png" alt="Beekeeper Studio 截图来自项目主页" /></li></ul></li><li>容器与虚拟化<ul><li><a href="https://www.docker.com/">Docker</a></li><li><a href="https://www.virtualbox.org/">Virtual Box</a></li><li><a href="https://www.vmware.com/cn/products/fusion.html"><em>VMWare Fusion</em></a></li></ul></li><li>Sourcetree<ul><li>Git 的 GUI 前端</li></ul></li><li>GitHub Desktop<ul><li>不为别的，就为写 commit 的时候可以使用 GitHub 的 emoji</li></ul></li><li><a href="https://kapeli.com/dash">Dash</a><br /><img src="https://kapeli.com/img/screen.png" alt="Dash 截图来自官网" /><ul><li>文档管理工具</li><li>插件支持各大编辑器、IDE</li></ul></li><li>Sourcetrail<ul><li>开源代码分析工具，类似 Source Insight</li></ul></li><li>Postman</li><li>iTerm2</li><li><a href="http://lldb.llvm.org/">LLDB</a></li><li><a href="https://www.qemu.org/">QEMU</a></li></ul><h3 id="极客向"><a class="markdownIt-Anchor" href="#极客向"></a> 极客向</h3><ul><li><a href="https://www.realvnc.com/">VNC Viewer</a><ul><li>主要用于树莓派</li></ul></li><li>Microsoft Remote Desktop<ul><li>RDP 远程桌面连接</li></ul></li><li><a href="https://www.veracrypt.fr/en/Home.html">VeraCrypt</a><ul><li>新建一个加密的虚拟磁盘文件，挂载后可保存文件</li></ul></li><li><a href="https://www.balena.io/etcher/">BalenaEther</a><ul><li>跨平台</li><li>macOS 风格 的UI，从一众刻盘软件里脱颖而出</li><li>主要用于烧录树莓派</li></ul></li><li>ClashX：流量控制</li><li>Textual：IRC 客户端，Mac App Store，完整版需 <strong>付费</strong></li></ul><h3 id="终端向"><a class="markdownIt-Anchor" href="#终端向"></a> 终端向</h3><ul><li>HomeBrew</li><li>Tmux</li><li>Zsh：终极 Shell<br /><img src="https://ohmyz.sh/img/themes/nebirhos.jpg" alt="#b# Oh My Zsh 截图来自官网" /><ul><li><a href="https://ohmyz.sh/">Oh My Zsh</a>：Zsh 配置的一套框架，SpaceVim 之于 Vim，也可使用 Fish 开箱即用</li><li>z</li><li>git</li><li>zsh-syntax-highlighting</li><li>zsh-autosuggestions</li><li>cp</li><li>extract</li><li>docker</li><li>docker-compose</li></ul></li><li>wget</li><li>thefuck</li><li><a href="https://ffmpeg.org/">ffmpeg</a></li><li>foremost</li><li>exiftool</li><li>tldr：简略版 <code>man</code></li><li>exa：高亮版 <code>ls</code>，可显示层级，类似 <code>tree</code></li><li>cloc：统计代码量</li><li>mycli：MySQL 客户端增强</li></ul><h3 id="安全向"><a class="markdownIt-Anchor" href="#安全向"></a> 安全向</h3><ul><li>AntSword</li><li><a href="https://binary.ninja/">Binary Ninja</a>：逆向分析工具</li><li><em>IDA Pro</em></li><li><a href="https://portswigger.net/">Burp Suite</a></li><li><a href="https://www.wireshark.org/">Wireshark</a></li><li>010 Editor：二进制编辑器</li><li>Mediainfo：查看音频参数</li><li><a href="https://www.audacityteam.org/">Audacity</a>：音频处理</li><li><a href="https://x64dbg.com/">x64dbg</a><br /><img src="https://x64dbg.com/img/slide3.png" alt="#b# x64dbg 截图来自官网" /></li><li>虚拟化环境<ul><li>SQLmap</li><li>GDB<ul><li>peda</li><li>pwndbg</li></ul></li><li><a href="https://www.metasploit.com/">Metasploit Framework</a></li></ul></li></ul><h2 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h2><h3 id="浏览器插件"><a class="markdownIt-Anchor" href="#浏览器插件"></a> 浏览器插件</h3><ul><li>Tampermonkey</li><li>AdGuard<ul><li>广告拦截</li><li>可拦截部分视频广告</li><li>同类有 ADBlock Plus 等</li></ul></li><li>Copyfish Free OCR Software<ul><li>OCR 插件</li></ul></li><li>IP Address and Domain Information</li><li>Wappalyzer<ul><li>检测网站技术栈</li></ul></li><li>Octotree</li><li>Gitako - GitHub file tree<ul><li>类似 Octotree</li></ul></li><li>RSSHub Radar</li><li>Dark Reader</li><li>Smart TOC<ul><li>墙裂推荐</li><li>给没有 TOC 侧栏如知乎、简书等站点的页面加目录</li><li>基于 HTML标签</li></ul></li><li>User-Agent Switcher and Manager<ul><li>UA 切换插件</li><li>支持多种操作系统、浏览器、版本</li></ul></li><li>Extension Manager<ul><li>插件管理插件，减少浏览器内存消耗</li><li>支持分组管理，一键切换</li></ul></li><li>CoCoCut<ul><li>视频下载插件</li><li>类似插件很多</li></ul></li><li>彩云小译</li><li>HackBar</li><li>Proxy SwitchyOmega</li><li>Web Scraper</li><li>IGG 谷歌访问助手</li><li>开发<ul><li>FeHelper</li><li>React Developer Tools</li><li>Vue.js devtools</li><li>MobX Developer Tools</li><li>Redux DevTools</li><li>React Context DevTool</li><li>React-Sight</li></ul></li></ul><h3 id="vscode-插件"><a class="markdownIt-Anchor" href="#vscode-插件"></a> VSCode 插件</h3><ul><li>C/C++</li><li>Dart</li><li>Python</li><li>Rust</li><li>CodeLLDB<ul><li>Rust 调试工具</li></ul></li><li>Code Runner</li><li>Docker</li><li>Debug Visualizer<ul><li>可视化调试工具</li><li>目前支持 Python、JS 等语言</li></ul></li><li>Debugger for Firefox<ul><li>同类有 Debugger for Chrome、Debugger for Edge</li></ul></li><li>Bracket Pair Colorizer<ul><li>彩虹花括号</li></ul></li><li>Auto Comment Blocks<ul><li>自动生成注释格式</li></ul></li><li>Better TOML<ul><li>高亮 TOML</li><li>Rust 的配置文件</li></ul></li><li>VimL<ul><li><code>.vimrc</code> 文件高亮</li></ul></li><li>Todo Tree<ul><li>高亮 TODO 项</li><li>在侧边栏列出</li><li>可自定义标签</li></ul></li><li>Bookmarks<ul><li>添加删除书签</li><li>缺点：基于行，删除一行代码不会随之移动</li></ul></li><li>ES7 React/Redux/GraphQL/React-Native/JS-Snippets</li><li>Vetur<ul><li>Vue 官方插件</li></ul></li><li>ESLint<ul><li>代码风格检测工具</li></ul></li><li>HexEditor<ul><li>二进制编辑器</li></ul></li><li>Regex Previewer<ul><li>实时调试正则表达式</li></ul></li><li>HTML CSS Support</li><li>Markdown All in One</li><li>Markdown Preview Enhanced</li><li>Prettier - Code Formatter</li><li>open in browser</li><li>One Dark Pro</li><li>Material Icon Theme</li></ul><h2 id="设备"><a class="markdownIt-Anchor" href="#设备"></a> 设备</h2><ol><li><s>Xiaomi Notebook Pro 15.4</s> 2020.10 更新为 Macbook Pro(13-inch 2020 4 Ports)</li><li>iPad 2018 + Apple Pencil 1 <sup>gen</sup></li><li>Raspberry Pi 3B，TF 卡若干，256MB ~ 8GB 不等</li><li>Seagate Backup Plus+ 1TB</li></ol><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>观察细心的读着可能看到有些工具标为斜体</p><p>本文将长期不定期更新，目前所列工具的说明较少，链接不全，后续将逐步完善。</p>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 参考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发小记——Web Audio API</title>
      <link href="2020/04/kai-fa-xiao-ji-web-audio-api/"/>
      <url>2020/04/kai-fa-xiao-ji-web-audio-api/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近在做一个在线语音聊天室的项目，在此之前零经验，所以疯狂爬帖。对于 Web Audio API 来说，除了 MDN 之外，资料不是特别多，<a href="https://juejin.im/" title="主页">掘金</a> 和 <a href="https://segmentfault.com/" title="主页">思否</a> 文章相对集中，但也不全是新的，这就导致了一个刚入手就会遇到的坑。</p><blockquote><p>本文重点不是介绍 Web Audio API，而是分享开发时的历程。若想获得更多知识以及技术细节，请参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" title="Web Audio API - MDN">MDN</a> 和文末 <a href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">推荐阅读</a> 中的文章。</p></blockquote><p>测试环境：</p><ul><li>Mozilla Firefox：v75.0</li><li>Microsoft Edge：v81.0.416.64</li></ul><h2 id="getusermedia"><a class="markdownIt-Anchor" href="#getusermedia"></a> getUserMedia</h2><p>使用 Web Audio API 进行录音，第一步就是要拿到浏览器的录音 API 以及获得相应的录音权限，部分文章会使用 <code>navigator.getUserMedia()</code> 这个 API。为解决不同浏览器兼容性问题，有形如以下的代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">navigator<span class="token punctuation">.</span>getUserMedia <span class="token operator">=</span>navigator<span class="token punctuation">.</span>getUserMedia <span class="token operator">||</span>navigator<span class="token punctuation">.</span>webkitGetUserMedia <span class="token operator">||</span>navigator<span class="token punctuation">.</span>mozGetUserMedia <span class="token operator">||</span>navigator<span class="token punctuation">.</span>msGetUserMedia<span class="token punctuation">;</span>navigator<span class="token punctuation">.</span><span class="token function">getUserMedia</span><span class="token punctuation">(</span>constraints<span class="token punctuation">,</span> sucCallBack<span class="token punctuation">,</span> errCallBack<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码是在三四年前（当前 2020 年）的历史条件下形成的，在 Firefox 下运行可能会有以下警告⚠️：</p><p><img src="https://s1.ax1x.com/2020/04/28/J42AqU.png" alt="#b# getUserMedia() 的警告" /></p><p>访问 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/getUserMedia" title="Navigator.getUserMedia - MDN">MDN 对应页面</a>，可以看到该 API 被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia" title="MediaDevices.getUserMedia - MDN"><code>MediaDevices.getUserMedia()</code></a> 取代，并且结合了 Promise。作为 Navigator 的一个子对象，调用形式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">navigator<span class="token punctuation">.</span>mediaDevices<span class="token punctuation">.</span><span class="token function">getUserMedia</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> audio<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> video<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">stream</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">/* 使用 stream */</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">/* 处理 error */</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 Promise 的 <code>then()</code> resolve <code>sucCallBack()</code> 处理成功的回调，<code>catch()</code> reject <code>errCallBack()</code> 处理失败的回调，<code>constraints</code> 照旧。</p><blockquote><p>返回一个 Promise 对象，成功后会 resolve 回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise 会 reject 回调一个 <code>PermissionDeniedError</code> 或者 <code>NotFoundError</code>。</p></blockquote><blockquote><p>返回的 promise 对象可能既不会 resolve 也不会 reject，因为用户不是必须选择允许或拒绝。</p></blockquote><p>版本问题不能算是坑，毕竟要考虑项目的用户对象等各种原因，但对于一个刚入坑的新人来讲，很容易摸不着头脑，不知孰对孰错。</p><p>好，通过 <code>navigator.mediaDevices.getUserMedia()</code> 指定的 resolve 函数，现在可以得到 <code>stream</code> 了，这是一个 MediaStream 媒体流，可以直接作为音频或视频的播放源。那么，如何播放呢？创建 <code>&lt;audio&gt;</code> 或者 <code>&lt;video&gt;</code> 标签，填写 <code>src</code> 属性然后触发响应事件就行，OK 文章结束。是吗？强大的 HTML5 可不这么认为，了解了 <a href="#%E9%9F%B3%E9%A2%91%E5%9B%BE">音频图</a>，你就会知道原来代码不仅可以作画，还可以 <a href="https://www.zhangxinxu.com/wordpress/2017/06/html5-web-audio-api-js-ux-voice/" title="张鑫旭的博客">写音乐</a>。</p><p>在了解播放音频之前，不妨先来看看这些音乐数据的格式。</p><h2 id="获取数据"><a class="markdownIt-Anchor" href="#获取数据"></a> 获取数据</h2><p>JS 获取二进制数据的方式不少，比较常见的就是读取为 ArrayBuffer 和 Blob。</p><h3 id="file-对象"><a class="markdownIt-Anchor" href="#file-对象"></a> File 对象</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loadFile(e)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <code>&lt;input&gt;</code> 标签上传文件，然后使用 FileReader 对象读取文件。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">loadFile</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reader<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> arrayBuffer <span class="token operator">=</span> reader<span class="token punctuation">.</span>result<span class="token punctuation">;</span><span class="token comment">// 处理 arrayBuffer</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>reader<span class="token punctuation">.</span><span class="token function">readAsArrayBuffer</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时 <code>arrayBuffer</code> 是 ArrayBuffer 实例，可以通过 <code>Blob()</code> 构造 Blob 对象，进而创建 Blob URL。</p><h3 id="blob-url"><a class="markdownIt-Anchor" href="#blob-url"></a> Blob URL</h3><blockquote><p><code>URL.createObjectURL()</code> 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的 URL 对象表示指定的 File 对象或 Blob 对象。</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">reader<span class="token punctuation">.</span><span class="token function-variable function">load</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">let</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>arrBuf<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>type<span class="token operator">:</span> <span class="token string">"audio/wav"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> blobURL <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>doucment<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"audio"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> blobURL<span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>blobURL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用完需要释放资源</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Blob URL 可以像一般的 HTTP URL 引用，但只能在浏览器的单个实例中和同一个会话中。而正是绑定了 document 对象，所以每次使用完尽量释放，尽管页面在关闭时浏览器会自动清理 document。</p><p>实际上 File 继承了 Blob，拥有其所有接口，所以 <code>file</code> 实例其实无需经过 Blob 可直接创建 Blob URL：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">reader<span class="token punctuation">.</span><span class="token function-variable function">load</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>blobUrl <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="arraybuffer"><a class="markdownIt-Anchor" href="#arraybuffer"></a> ArrayBuffer</h3><p>调用 FileReader 对象的 <code>readAsArrayBuffer()</code> 方法后，读取 <code>result</code> 实例属性，可以获得转换后的 ArrayBuffer 对象，借助 <code>TypedeArray</code> 或 <code>DataView</code> 对象可实现自定义操作。</p><h3 id="xhr"><a class="markdownIt-Anchor" href="#xhr"></a> XHR</h3><p>使用 HTTP 协议的 AJAX，可以发送或者接受二进制文件。</p><ul><li>接受：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token constant">XHR</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"/myfile.png"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">XHR</span><span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"arraybuffer"</span><span class="token punctuation">;</span><span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> buf <span class="token operator">=</span> <span class="token constant">XHR</span><span class="token punctuation">.</span>response<span class="token punctuation">;</span><span class="token comment">// 获得 ArrayBuffer</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>也可直接构造 Blob  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">XHR</span><span class="token punctuation">.</span>response<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">"image/png"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>或者设置 <code>responseType</code> 为 <code>blob</code>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">XHR</span><span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"blob"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li>发送：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> myArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> longInt8View <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token constant">XHR</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>longInt8View<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>XHR 增强的 <code>send()</code> 方法可直接发送二进制文件。</li></ul><h3 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h3><p>同样 WebSocket 的 <code>send()</code> 方法也可直接发送二进制格式，具体有以下类型：</p><ul><li>USVString</li><li>Blob</li><li>ArrayBuffer</li></ul><p>而接收时，浏览器可能会进行解析，因此必要时需在连接前指定 <code>binarytype</code> 属性。如果发送是以 Blob，那么接收也应该按相同的格式接收。除却 USVString，两种类型大致相同，Blob 适合直接保存为文件，ArrayBuffer 适合在内存中编辑（毕竟有 <code>TypedeArray</code> 和 <code>DataView</code>）。</p><h2 id="音频图"><a class="markdownIt-Anchor" href="#音频图"></a> 音频图？</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" title="Web Audio API - MDN">MDN</a> 对 Web Audio API 是这样介绍的：</p><blockquote><p>Web Audio API 使用户可以在<em>音频上下文</em>(AudioContext)中进行音频操作，具有<em>模块化路由</em>的特点。在<em>音频节点</em>上操作进行基础的音频， 它们连接在一起构成<em>音频路由图</em>。</p></blockquote><p>下方还有这样的章节：</p><p><img src="https://s1.ax1x.com/2020/04/28/J42VZF.png" alt="#b# 音频图?" /></p><p>什么是音频图呢？乍接触到时云里雾里的，直接翻文档不知所云，所以还是得先读一读其他的文章。爬帖一波，再结合文档，我整理了如下一张图：</p><p><img src="https://s1.ax1x.com/2020/04/28/J42krT.png" alt="#b# Audio API 的大体结构" /></p><p>可以看到，AudioContext 和 AudioNode 衍生出了一系列对象。不得不说，Web 的对象和 API 真是多，而且相互交织，不画个示意图真不好理解。</p><h3 id="创建-audiocontext"><a class="markdownIt-Anchor" href="#创建-audiocontext"></a> 创建 AudioContext</h3><p>AudioContext 翻译为 <em>音频上下文</em>，对音频的一切操作都在这个环境里进行，就像一个工厂。自然而然的会想到，AudioContext 可以类比 Canvas 中 <code>getContext()</code>。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> AudioContext <span class="token operator">=</span> window<span class="token punctuation">.</span>AudioContext <span class="token operator">||</span> window<span class="token punctuation">.</span>webkitAudioContext<span class="token punctuation">;</span><span class="token keyword">const</span> audioContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有了 AudioContext 后，就可以创建音频/视频源了，来源有下面几个。</p><h3 id="audiobuffersourcenode"><a class="markdownIt-Anchor" href="#audiobuffersourcenode"></a> AudioBufferSourceNode</h3><p>AudioBufferSourceNode 对象由 AudioContext 实例的 <code>createBufferSource()</code> 方法创建。</p><p>顾名思义，就是音视频的起点，是一个 AudioNode。有以下常用属性：</p><ul><li><code>buffer</code>：是一个 AudioBuffer 对象，表示要播放的音频</li><li><code>loop</code>：布尔值。是否重播，默认 <code>false</code></li><li><code>connect</code>：继承自 <a href="#audionode" title="跳转到该节">AudioNode</a></li></ul><p>使用以下方法开始和暂停：</p><ul><li><code>start(when[, offset][, duration])</code>：从 <code>when</code> 开始播放<br />只能被播放一次，也就是每次 <code>start()</code> 后，如果想再播放一遍，就需要重新创建，不过创建该节点代价不大</li><li><code>stop([when])</code>：到 <code>when</code> 停止播放<br />不同于 <code>start()</code>，可以多次调用</li></ul><p>该节点的 <code>buffer</code> 属性指向一个 AudioBuffer 对象，这个对象是由 AudioContext 的方法创建的。前面提到，通过 XHR 或者 File 获得二进制文件。我们都知道音视频都有压缩（所以产生了各种压缩格式），播放前得先解码，所以下面两个函数就是用来将之解码为可播放的 buffer。</p><h4 id="decodeaudiodata"><a class="markdownIt-Anchor" href="#decodeaudiodata"></a> <code>decodeAudioData()</code></h4><p>该函数可实现从 <strong>音频文件</strong> 的 ArrayBuffer 异步解码。新版 API 使用 Promise 的形式。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">decodeAudioData</span><span class="token punctuation">(</span><span class="token constant">XHR</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">buffer</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">// 处理 buffer</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">// 处理错误</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="createbuffer"><a class="markdownIt-Anchor" href="#createbuffer"></a> <code>createBuffer()</code></h4><p>新建一个空白的 AudioBuffer 对象，以便用于填充数据，通过 AudioBufferSourceNode 播放。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> emptyBuffer <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">createBuffer</span><span class="token punctuation">(</span>numOfChan<span class="token punctuation">,</span> len<span class="token punctuation">,</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>numOfChan</code>：声道数</li><li><code>len</code>：长度</li><li><code>rate</code>：采样频率</li></ul><h3 id="audiodestinationnode"><a class="markdownIt-Anchor" href="#audiodestinationnode"></a> AudioDestinationNode</h3><p>为了遵循行文逻辑，而保持层次结构上清晰，这部分见 <a href="#destination"><code>destination</code></a>。</p><h3 id="mediaelementaudiosourcenode"><a class="markdownIt-Anchor" href="#mediaelementaudiosourcenode"></a> MediaElementAudioSourceNode</h3><ul><li>表示由 HTML5 <code>&lt;audio&gt;</code> 或 <code>&lt;video&gt;</code> 元素生成的音频源</li><li>这是一个作为音频源的 AudioNode</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> audioCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window<span class="token punctuation">.</span>AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> audio <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'audio'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> source <span class="token operator">=</span> audioCtx<span class="token punctuation">.</span><span class="token function">createMediaElementSource</span><span class="token punctuation">(</span>audio<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="mediastreamaudiosourcenode"><a class="markdownIt-Anchor" href="#mediastreamaudiosourcenode"></a> MediaStreamAudioSourceNode</h3><ul><li>表示由 WebRTC MediaStream（如网络摄像头或麦克风）生成的音频源</li><li>这是一个作为音频源的 AudioNode</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">navigator<span class="token punctuation">.</span>mediaDevices<span class="token punctuation">.</span><span class="token function">getUserMedia</span><span class="token punctuation">(</span>constraints<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">stream</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> audioCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window<span class="token punctuation">.</span>AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> source <span class="token operator">=</span> audioCtx<span class="token punctuation">.</span><span class="token function">createMediaStreamSource</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接-connect"><a class="markdownIt-Anchor" href="#连接-connect"></a> 连接 <code>connect()</code></h2><p>有了起点和音源/视频源，现在可以播放了。怎么操作呢？很简单，连接到扬声器/屏幕就行了。把大象塞到冰箱里的第三步——关上冰箱门。在这里是连接到终点。</p><h3 id="destination"><a class="markdownIt-Anchor" href="#destination"></a> <code>destination</code></h3><p>所谓终点，由 AudioContext 的 <code>destination</code> 定义，是一个 AudioDestinationNode 对象，该对象也是个 AudioNode，一般表示最终的渲染设备。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> audioCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> source <span class="token operator">=</span> audioCtx<span class="token punctuation">.</span><span class="token function">createMediaElementSource</span><span class="token punctuation">(</span><span class="token string">"element"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>source<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>audioCtx<span class="token punctuation">.</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>disconnect()</code> 方法断开连接，可以实现停止播放，再次 <code>connect()</code> 即可继续。</p><p>对于 WebRTC MediaStream，媒体流可以存储在本地文件或者被发送到另外一台计算机，使用 <code>createMediaStreamDestination()</code> 方法创建一个对象，关联一个音频流。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> audioCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> destination <span class="token operator">=</span> audioCtx<span class="token punctuation">.</span><span class="token function">createMediaStreamDestination</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签的功能好像都实现了，但 Web Audio API 的功能远不止这些。翻看 MDN 文档，会发现有一堆 <code>*Node</code>，这些对象都是继承自 AudioNode，正如示意图所呈现的。</p><h3 id="audionode"><a class="markdownIt-Anchor" href="#audionode"></a> AudioNode</h3><p>该接口是处理音视频的通用模块，可以衍生出各种不同功能的模块，正如上文多次提到的“作为 <code>AudioNode</code>”</p><ul><li>AudioBufferSourceNode，它的数据来源于一个解码好的完整的 buffer</li><li>GainNode：用于设置音量</li><li>OscillatorNode：用于产生周期性波形</li><li>BiquadFilterNode：用于滤波</li><li>ScriptProcessorNode：用 JS 处理音频，见 <a href="#scriptprocessornode">下文</a></li><li>MediaStreamAudioSourceNode：用于连接麦克风设备</li></ul><p>这些模块既有输入也有输出，可以用装饰者模式一层层 connect，不同的节点可以 <strong>连接</strong> 在一起构建一个处理图。</p><p><img src="https://mdn.mozillademos.org/files/7949/voice-change-o-matic-graph.png" alt="#b# 音频节点图 - MDN" /></p><h3 id="gainnode"><a class="markdownIt-Anchor" href="#gainnode"></a> GainNode</h3><p>是用于修改音量的节点，现在可以写一个音乐播放器了（逃</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> gainNode <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createGain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>source<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>gainNode<span class="token punctuation">)</span><span class="token punctuation">;</span>gainNode<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>连接好后可以通过修改 <code>value</code> 值更改音量：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">gainNode<span class="token punctuation">.</span>gain<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="代码与艺术"><a class="markdownIt-Anchor" href="#代码与艺术"></a> 代码与艺术</h3><p>借助各式各样的音频模块，处理一段音频或者生成一段音频不在话下，甚至还能用声音作画（AnalyserNode），我不通乐理、不懂声学，暂且不深入学习。分享几个与 Web Audio API 相关的网页：</p><ul><li><a href="http://mdn.github.io/violent-theremin/">Violent Theremin</a></li><li><a href="https://mdn.github.io/voice-change-o-matic/">Voice change o matic</a></li><li><a href="https://airtightinteractive.com/demos/js/reactive">Loop Waveform Visualizer</a></li></ul><p>若有兴趣可移步 <a href="https://github.com/yrq110/odds-and-ends/blob/master/%E6%8A%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%98%E6%88%90%E9%92%A2%E7%90%B4%EF%BC%81Web%20Audio%20API%E5%85%A5%E9%97%A8.md" title="博客文章">把浏览器变成钢琴！Web Audio API入门</a>。</p><h2 id="录音"><a class="markdownIt-Anchor" href="#录音"></a> 录音</h2><p>大致了解了 Audio API，但还没解决录音的问题，录音这部分资料不是太多，但模式大致相同。</p><ol><li>使用 WebRTC 的 <code>getUserMedia()</code> 获取 MediaStream</li><li>使用这个流初始化（<code>createMediaStreamSource()</code>）一个 <a href="#mediastreamaudiosourcenode">MediaStreamAudioSourceNode</a> 音频模块</li><li>将节点连接到 ScriptProcessorNode（<code>createScriptProcessor()</code>）——使用 JS 处理音频的节点</li><li>设置 ScriptProcessorNode 的 <code>onaudioprocess</code> 事件的回调函数</li></ol><h3 id="scriptprocessornode"><a class="markdownIt-Anchor" href="#scriptprocessornode"></a> ScriptProcessorNode</h3><p>通过这个节点，可以使用 JS 操作音频，进一步让用代码写音乐成为可能。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> audioCtx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>scriptNode <span class="token operator">=</span> audioCtx<span class="token punctuation">.</span><span class="token function">createScriptProcessor</span><span class="token punctuation">(</span>bufferSize<span class="token punctuation">,</span> numrOfIn<span class="token punctuation">,</span> numOfOut<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>bufferSize</code>：缓冲区大小，应为 2 的幂，通常为 <code>4096</code></li><li><code>numOfIn</code>：输入声道数，默认 <code>2</code>，最高 <code>32</code></li><li><code>numOfOut</code>：输出声道数，默认 <code>2</code>，最高 <code>32</code></li></ul><h3 id="onaudioprocess-事件"><a class="markdownIt-Anchor" href="#onaudioprocess-事件"></a> <code>onaudioprocess</code> 事件</h3><p>该事件对象有以下两个缓冲区（AudioBuffer 对象）：</p><ul><li><code>inputBuffer</code></li><li><code>outputBuffer</code></li></ul><p>使用 <code>getChannelData(num)</code> 方法可获得该 <code>num</code> 声道的数据，数据以 Float32Array 对象存储。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">onAudioProcess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> audioBuffer <span class="token operator">=</span> event<span class="token punctuation">.</span>inputBuffer<span class="token punctuation">;</span>    <span class="token keyword">let</span> leftChannelData <span class="token operator">=</span> audioBuffer<span class="token punctuation">.</span><span class="token function">getChannelData</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rightChannelData <span class="token operator">=</span> audioBuffer<span class="token punctuation">.</span><span class="token function">getChannelData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 处理两个声道的数据</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合并声道"><a class="markdownIt-Anchor" href="#合并声道"></a> 合并声道</h3><p>各个声道是分离的，如果要存储然后播放，按时间先后排布显然是不行的，所以要合并，左右声道交叉存储和播放。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 交叉合并左右声道的数据</span><span class="token keyword">const</span> <span class="token function-variable function">combine</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> totalLength <span class="token operator">=</span> left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编码并传输"><a class="markdownIt-Anchor" href="#编码并传输"></a> 编码并传输</h3><p>编码为 WAV 格式的函数经过不断改进，可以直接使用。编码以及压缩后的数据（Blob）可以直接保存/发送。但是在实时通信的场景下，数据应该是源源不断地产生和消耗，所以要用到流。开辟一块缓冲区，隔一段时间取出发送，并清空缓冲区，当这个间隔时间大小合适，就能产生实时的效果。</p><p>感谢腾讯 AlloyTeam 全端团队来自 2015 年的 <a href="http://www.alloyteam.com/2015/12/websockets-ability-to-explore-it-with-voice-pictures">文章</a>，给出了 Audio API 结合 WebSocket 进行录制与传输的方案。我在此基础上稍作修改，分理出两个类，项目的烂代码还没开源，为不影响阅读暂把前人的智慧贴在文章末尾。（可自定义的参数太多了，全部提取出来有点繁琐，所以部分参数硬编码了。）</p><h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2><blockquote><p>注意本节内容列出阅读的文章，虽然也是写作本文的参考文章，读到这里时也建议移步吸取灵感。</p></blockquote><ol><li><a href="https://juejin.im/post/599e35f5f265da246c4a1910">深入浅出 Web Audio Api - 掘金</a></li><li><a href="https://juejin.im/entry/588ca34e8fd9c5d09bbcaad4">大话Web-Audio-Api - 掘金</a></li><li><a href="https://juejin.im/post/5cbfdd4ee51d456e6f45c721">初识HTML5 Web Audio API - 掘金</a></li><li><a href="https://juejin.im/post/5b8bf7e3e51d4538c210c6b0">如何实现前端录音功能 - 掘金</a></li><li><a href="https://segmentfault.com/a/1190000010561222">HTML5音频API Web Audio - 思否</a></li><li><a href="https://www.jianshu.com/p/62790429acef">基于WebSocket的在线聊天室（一） - 简书</a></li><li><a href="https://www.jianshu.com/p/03a74d489f34">基于WebSocket的在线聊天室（二） - 简书</a></li><li><a href="http://www.alloyteam.com/2015/12/websockets-ability-to-explore-it-with-voice-pictures">websocket 探索其与语音、图片的能力</a></li><li><a href="https://github.com/yrq110/odds-and-ends/blob/master/%E6%8A%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%98%E6%88%90%E9%92%A2%E7%90%B4%EF%BC%81Web%20Audio%20API%E5%85%A5%E9%97%A8.md">把浏览器变成钢琴！Web Audio API入门</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API - MDN</a></li></ol><h2 id="附录代码"><a class="markdownIt-Anchor" href="#附录代码"></a> 附录：代码</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SAudioData</span> <span class="token punctuation">&#123;</span><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">rate</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 录音文件长度</span><span class="token keyword">this</span><span class="token punctuation">.</span>buffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 录音缓存</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputSampleRate <span class="token operator">=</span> rate<span class="token punctuation">;</span> <span class="token comment">// 输入采样率</span><span class="token keyword">this</span><span class="token punctuation">.</span>outputSampleRate <span class="token operator">=</span> <span class="token number">44100</span> <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 输出的采样率,取决于平台</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputSampleBits <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 输入采样位数 8, 16</span><span class="token keyword">this</span><span class="token punctuation">.</span>outputSampleBits <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 输出采样位数 8, 16</span><span class="token punctuation">&#125;</span><span class="token comment">// 填入缓冲区</span><span class="token function-variable function">inputData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>buffer<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">+=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 清理缓冲区</span><span class="token function-variable function">clearData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>buffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 合并压缩</span><span class="token function-variable function">compress</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>buffer<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>data<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>offset <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 压缩</span><span class="token keyword">var</span> compression <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputSampleRate <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outputSampleRate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> length <span class="token operator">=</span> data<span class="token punctuation">.</span>length <span class="token operator">/</span> compression<span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j <span class="token operator">+=</span> compression<span class="token punctuation">;</span>index<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 编码为 WAV，Blob</span><span class="token function-variable function">encodeWAV</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> sampleRate <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputSampleRate<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outputSampleRate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> sampleBits <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputSampleBits<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outputSampleBits<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> bytes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> dataLength <span class="token operator">=</span> bytes<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token punctuation">(</span>sampleBits <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">44</span> <span class="token operator">+</span> dataLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataView</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> channelCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 单声道</span><span class="token keyword">var</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token function-variable function">writeString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>data<span class="token punctuation">.</span><span class="token function">setUint8</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> i<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token string">"RIFF"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 资源交换文件标识符</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint32</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> <span class="token number">36</span> <span class="token operator">+</span> dataLength<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 下个地址开始到文件尾总字节数，即文件大小 -8</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token string">"WAVE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// WAV 文件标志</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token string">"fmt "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 波形格式标志</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint32</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 过滤字节,一般为 0x10 = 16</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint16</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 格式类别 (PCM 形式采样数据)</span>offset <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint16</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> channelCount<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通道数</span>offset <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint32</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> sampleRate<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 采样率，每秒样本数,表示每个通道的播放速度</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint32</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> channelCount <span class="token operator">*</span> sampleRate <span class="token operator">*</span> <span class="token punctuation">(</span>sampleBits <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint16</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> channelCount <span class="token operator">*</span> <span class="token punctuation">(</span>sampleBits <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8</span>offset <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint16</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> sampleBits<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每样本数据位数</span>offset <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据标识符</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setUint32</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> dataLength<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 采样数据总数，即数据总大小-44</span>offset <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 写入数据</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sampleBits <span class="token operator">===</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> offset<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> s <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> val <span class="token operator">=</span> s <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> s <span class="token operator">*</span> <span class="token number">0x8000</span> <span class="token operator">:</span> s <span class="token operator">*</span> <span class="token number">0x7fff</span><span class="token punctuation">;</span>val <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">255</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">65535</span> <span class="token operator">/</span> <span class="token punctuation">(</span>val <span class="token operator">+</span> <span class="token number">32768</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setInt8</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> offset <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> s <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">.</span><span class="token function">setInt16</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> s <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> s <span class="token operator">*</span> <span class="token number">0x8000</span> <span class="token operator">:</span> s <span class="token operator">*</span> <span class="token number">0x7fff</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">"audio/wav"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SRecorder</span> <span class="token punctuation">&#123;</span><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">stream</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>clock <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 循环定时器</span><span class="token comment">// 音频处理接口</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过音频流创建输入音频对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioInput <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>audioContext<span class="token punctuation">.</span><span class="token function">createMediaStreamSource</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建音频数据对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SAudioData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioContext<span class="token punctuation">.</span>sampleRate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建音量对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioVolume <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>audioContext<span class="token punctuation">.</span><span class="token function">createGain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建录音机对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>recorder <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>audioContext<span class="token punctuation">.</span><span class="token function">createScriptProcessor</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function-variable function">onaudioprocess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioData<span class="token punctuation">.</span><span class="token function">inputData</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>inputBuffer<span class="token punctuation">.</span><span class="token function">getChannelData</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 开始录音</span><span class="token function-variable function">start</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioInput<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioVolume<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioVolume<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>recorder<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioContext<span class="token punctuation">.</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span>callback <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 停止录音</span><span class="token function-variable function">stop</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 暂停录音</span><span class="token function-variable function">pause</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioVolume<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 继续录音</span><span class="token function-variable function">continue</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>recorder<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioContext<span class="token punctuation">.</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span>callback <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 获取 WAV 数据</span><span class="token function-variable function">getWav</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>audioData<span class="token punctuation">.</span><span class="token function">encodeWAV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 清除缓冲区</span><span class="token function-variable function">clear</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>audioData<span class="token punctuation">.</span><span class="token function">clearData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 循环拉取缓冲数据，使用 `callback()` 发送出去，该方法适用于流</span><span class="token function-variable function">cycle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> time <span class="token operator">=</span> <span class="token number">500</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> bTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWav</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>clock <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">,</span>time <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> bTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 音视频开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取 GitBook 站点的文档</title>
      <link href="2020/03/huo-qu-gitbook-zhan-dian-de-wen-dang/"/>
      <url>2020/03/huo-qu-gitbook-zhan-dian-de-wen-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="tldr"><a class="markdownIt-Anchor" href="#tldr"></a> TL;DR</h2><p>wget 加 <code>-m</code> 选项下载站点资源，然后使用 Python 提供的 SimpleHTTPServer 搭建简易服务器，可以实现在本地访问文档。</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>有些网站如果不用一些手段的话，访问速度特别慢，尤其是提供在线内容的网站比如官方文档，点半天没反应 <s>对，就是 GitHub 和 GitBook</s>，开发体验极差。如果能本地访问就好了，像 Java 开发可能会查阅 CHM 格式的 API 手册，速度就会快很多，还有一些文档工具，综合了大量离线文档，如 <a href="https://kapeli.com/dash" title="主页">Dash</a> 及与之对应的 <a href="https://zealdocs.org/" title="主页">Zeal</a>。</p><p>此处提供一个站点，可离线存储文档：<a href="https://devdocs.io/" title="主页">https://devdocs.io/</a>，用的前端技术栈。</p><p>水这么一篇文章，是因为最近阅读 <a href="https://chenxiaowei.gitbook.io/cpp_concurrency_in_action/" title="文档">《C++ 并发编程》</a>，切换页面速度太慢了，得想办法搞下来 &lt;.&lt;</p><h2 id="下载静态资源"><a class="markdownIt-Anchor" href="#下载静态资源"></a> 下载静态资源</h2><p>大多数文档都使用 <a href="https://www.gitbook.com/" title="主页">GitBook</a> 制作并托管，而 GitBook 是个静态页面，因此对于这类网页，可以下载静态资源到本地，从而加快访问速度。</p><p>正好该网站是用 GitBook 托管，每个页面都是 HTML 文件，所以在本地找个目录，<a href="https://www.gnu.org/software/wget/" title="主页">wget</a> 一把梭。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wget</span> -m https://xxx.xxx.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>-m</code> 是 <code>-N -r -l inf --no-remove-listing</code> 的缩写形式。</p><p>还可以使用如下选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wget</span> -k -r -c https://xxx.xxx.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-k, --convert-links</code>：让下载得到的 HTML 或 CSS 中的链接指向本地文件</li><li><code>-r, --recursive</code>：指定递归下载</li><li><code>-c, --continue</code>：断点续传下载文件</li><li><code>-np, --no-parent</code>：不追溯至父级，即只下载某子目录</li></ul><p>类似工具还有 <a href="http://www.httrack.com" title="主页">HTTrack</a> 等，可以镜像一个网站。</p><p>一波操作之后，在该目录就得到了网站的资源，双击 <code>index.html</code>（如果有的话），一个克隆网站映入眼帘，点击一个链接，如果没有使用 <code>-k</code> 选项的话，链接可能会失效，因为 URL 路径问题，关于 <code>file</code> 协议，<a href="https://palmcivet.github.io/2020/02/Github-%E4%B8%8E-SPA-%E9%83%A8%E7%BD%B2/" title="文章">这里</a> 有提到。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KheFx.png" alt="#b# 网站资源 download 到本地" /></p><h2 id="托管页面"><a class="markdownIt-Anchor" href="#托管页面"></a> 托管页面</h2><p>众所周知，使用 Apache 或者 Nginx 托管静态页面再好不过，但是为了查一下文档在生产机安装服务端软件属实欠妥，最为上乘的是轻量级的解决方案如使用一个脚本启动一个服务器。随手一查，果然存在。</p><p>SimpleHTTPServer 是 Python 2 自带的一个模块，是 Python 的 Web 服务器。它在 Python 3 已经合并到 <code>http.server</code> 模块中。SimpleHTTPServer 在 Python 3 的用法与在 Python 2 的用法相似。</p><p>在终端进入一个目录，执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python -m SimpleHTTPServer <span class="token number">6789</span>$ python3 -m http.server <span class="token number">6789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用浏览器输入 <a href="http://127.0.0.1:6789" title="打开">127.0.0.1:6789</a> 或 <a href="http://0.0.0.0:6789" title="打开">0.0.0.0:6789</a> 即可访问。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhEwR.png" alt="访问之，可看到日志记录" /></p><p>若当前目录存在 <code>index.html</code>，则默认显示该页面，否则显示为文件目录。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhVT1.png" alt="运行在本地的文档页面" /></p><p>其实 GitBook 也可以提供脚本和文件，可以在本地用这种方式运行一个网站的。&gt;.&lt;</p><h2 id="随时启动"><a class="markdownIt-Anchor" href="#随时启动"></a> 随时启动</h2><p>每次输命令哪够啊，肯定得 <code>alias</code> 一下，此后轻轻松松就可以打开服务器浏览任意文件了，开发的时候也可以做测试。<s>当然香还是 Webpack 的 DevServer 香</s>。</p><p>编辑 Shell 的配置文件（我使用 Zsh：<code>~/.zshrc</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">simple</span><span class="token operator">=</span><span class="token string">"python3 -m http.server 9999"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 macOS，有一个 <code>open</code> 命令，可以指定浏览器打开某个页面，如 <code>open https://www.bing.com</code> 使用默认浏览器打开 <a href="https://www.bing.com" title="主页">Bing</a>。当然也可指定浏览器，使用 <code>-a</code> 选项，比如 <code>open -a Firefox https://www.bing.com</code>。</p><p><code>-a</code> 选项其实是用来打开软件的，就是 <code>/Applications</code> 文件夹下的应用程序，URL 只是个参数。</p><p>回过头来，命令设置如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">simple</span><span class="token operator">=</span><span class="token string">"open http://0.0.0.0:9999 &amp;&amp; python3 -m http.server 9999"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因 SimpleHTTPServer 打开后一直处于前台运行，况且打开软件需要响应时间，所以将 <code>open</code> 命令提到前面，这样的调用顺序正好并行处理。打开后窗口的焦点落于浏览器，获得极致体验。</p><p>可以使用 <code>&amp;</code> 将命令放到后台而不占用终端，但简易服务器应随开随关，后台运行似乎不妥。</p><h2 id="局域网访问"><a class="markdownIt-Anchor" href="#局域网访问"></a> 局域网访问</h2><p>在局域网（使用无线路由器连接的家庭网络）内，PC、笔记本和手机等设备在同一网段，可通过内网相互访问。</p><p><img src="https://s1.ax1x.com/2020/03/13/8MpW8S.png" alt="查看 IP" /></p><p>查看一下 IP，绑定了本机地址，所以其他设备连接本机 IP 即可访问该页面：</p><p><img src="https://s1.ax1x.com/2020/03/13/8MC1T1.jpg" alt="#b# 移动端访问本地文档" /></p><h2 id="题外话apache"><a class="markdownIt-Anchor" href="#题外话apache"></a> 题外话：Apache</h2><p>macOS 系统对开发的友好之处就在于内置了一些必要的软件，曾经翻系统目录的时候找到过如下内容：</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhAm9.png" alt="#b# macOS 内置的 WebServer" /></p><p>没错正是 <a href="http://httpd.apache.org/" title="主页">Apache httpd</a>，虽然见怪不怪，但在 macOS 上找到 Apache 多少还是有点惊讶的</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhmY6.png" alt="#b# macOS 内置的 Apache" /></p><p>对于这个 httpd，可使用如下命令查看版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ apachectl -version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动与停用"><a class="markdownIt-Anchor" href="#启动与停用"></a> 启动与停用</h3><p>httpd 的管理需要 <code>sudo</code> 权限，默认运行在 <a href="http://0.0.0.0:80" title="打开"><code>80</code></a> 端口。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> apachectl start$ <span class="token function">sudo</span> apachectl stop$ <span class="token function">sudo</span> apachectl restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>打开浏览器查看，可以看到，后端操作系统是 UNIX（即 Darwin）。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhnfK.png" alt="It works！" /></p><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>网站根目录为 <code>/Library/WebServer/Documents/</code>。可编辑配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">vi</span> /etc/apache2/httpd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体配置项不做介绍，按照 Apache 文档配置即可。</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>可以想象，在下载时网站的流量必然不小，因此需审慎下载，此外，对于这类资源，应尊重作者的劳动成果，譬如我下载的文档是作者的译文，不应用作其他用途。</p><p>SimpleHTTPServer，Python2 就有了，十几年前吧，我应该不是最后一个知道 ╮(╯▽╰)╭，不过貌似以前看到过。但至少我知道，Python 可以架设一个 Web 服务器。好，就这样，水了一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 VSCode 和开发工具</title>
      <link href="2020/03/qian-tan-vscode-he-kai-fa-gong-ju/"/>
      <url>2020/03/qian-tan-vscode-he-kai-fa-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>早在今年二月份，我产生了一个自建云开发环境的想法，就是复刻微软的 Visual Studio Online，<s>（因为这一服务需要 Azure，而 Azure 要钱），</s> 然后在 iPad 上就可以码代码了，日常通勤只需携带 iPad。</p><p>地毯式搜索之后，发现解决方案还是不少的，<a href="https://github.com/cdr/code-server" title="GitHub"><em>Code Server</em></a> 就是其中一个，其本质就是魔改 VSCode。你也可以更极客（硬核）一点，VSCode 官方提供了 <a href="https://github.com/microsoft/vscode/wiki/How-to-Contribute" title="GitHub Wiki">编译步骤</a>，可以编译为 Web 应用，部署在自己的服务器上，成为比 <em>Code Server</em> 更原生的云编辑器。</p><p><img src="https://github.com/cdr/code-server/raw/main/docs/assets/screenshot.png" alt="Code Server - 图片来自官方 GitHub" /></p><p>除此之外，如 <a href="https://stackblitz.com/" title="主页">StackBlitz</a> 等其他解决方案以及具体玩法见后文 <s>，后文的意思是今后的文章（逃</s></p><p>之后（五月），GitHub 又推出了 <a href="https://github.com/features/codespaces" title="主页">Codespaces</a>，这么多项目<s>玩具</s>，谁是谁，关系又如何，完全搞不清楚，所以产生了一篇名为《非权威解读 Visual Studio “全家桶”》的文章草稿，只是开了个头，就搁置了。一是只介绍产品没什么深度，二是要学习新知识没精力<s>就是懒</s>，三是就这么点东西，关系厘清就好了，真没啥可写。再后来也就是现在（七月），应邀<s>硬要</s>介绍一下 VSCode 的基本玩法，并且讨论一些开发工具，作为入门<s>启蒙读物</s>还是有必要的，故而我就一瓶子不满半瓶子晃，厚着脸皮在此搬弄。</p><h2 id="开发工具"><a class="markdownIt-Anchor" href="#开发工具"></a> 开发工具</h2><p>大多数编程初学者用 C 语言入门，不少高校以及出版教材都使用 Visual C++ 6.0 作为开发工具进行演示，光这一点就被人诟病已久；另一方面，类似谭浩强版教材，或因写作历史久远缺乏更新，却因校方教材审校不当，或因作者只想完成任务，导致学习难度增加，提高了计算机专业的入门门槛（注意是对口的计算机专业，也就是说，消磨了热衷于学习的初学者的热情）。</p><p>我们盘点一下 C 教学经常用到的工具。</p><ul><li><a href="https://baike.baidu.com/item/Microsoft%20Visual%20C%2B%2B/8646587" title="百度知道">Microsoft Visual C++</a><ul><li>也称 MSVC，是微软的 C++ 开发工具，具有可视化界面（Visual）</li><li>6.0 版本于 1998 年发行</li><li>后来的版本被集成在 Visual Studio 中，成为其中的一个组件</li><li>历史久远，存在较多错误和兼容性问题</li></ul></li><li><a href="http://programarts.com/" title="主页">C Free</a><ul><li>国产收费软件</li><li>最新版为 5.0，发布于 2010 年 7 月 19 日</li></ul></li><li>Dev C++<ul><li>是一款开源的自由软件，集成了 MinGW 中的 GCC、GDB 等工具</li><li>原开发公司 <em>Bloodshed</em> 在开发完 <a href="https://sourceforge.net/projects/dev-cpp/" title="原 SourceForge">4.9.9.2</a> 后停止开发，现在由 <em>Orwell</em> 公司继续开发更新，称为 <a href="https://sourceforge.net/projects/orwelldevcpp/" title="新 SourceForge">orwelldevcpp</a></li><li>最新版为 5.12，发布于 2016 年 11 月 29 日</li></ul></li><li><a href="http://www.codeblocks.org/">Code::Blocks</a><ul><li>开源软件，跨平台（上述三款仅限 Windows 平台）</li><li>最新版为 20.03，发布于 2020 年 3 月 19 日</li></ul></li></ul><p>作为学习使用，比较推荐的是 Dev C++ 和 Code::Blocks。这些软件有一个共性：都是集成开发环境（简称 <a href="https://zh.wikipedia.org/zh-hans/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" title="Wiki">IDE</a>）。</p><h3 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h3><blockquote><p>集成开发环境（Integrated Development Environment，IDE），是用于提供程序开发环境的应用程序，一般包括代码 <em>编辑器</em>、<em>编译器</em>、<em>调试器</em> 和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套件。<br />—— 百度百科</p></blockquote><p>很多教材和教师在 C/C++ 入门介绍的时候，简略或忽略预处理、编译、汇编、链接这一过程，而在 Java 入门的时候，会强调体验一下“使用记事本写一个 <code>.java</code> 文件，然后用 <code>javac</code> 命令编译为 <code>.class</code> 文件，再使用 <code>java</code> 命令运行”这个过程。</p><p><img src="http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/67e5ff298100a5d491d1e610dab63905.jpg" alt="#b# C 编译过程 - 图片来自网络" /></p><p>实际上，编译型语言的运行都需要经过编译，转换成可执行文件方可运行。运行 Java 代码这一过程虽然不复杂，但开发时每次修改都要重复一遍，显然不人道。所以把这些重复动作交给脚本或者程序使其自动完成，程序员只需专注于代码本身，这样可以极大提高工作效率。</p><p>另一方面，程序出错之后需要找错误，使用各种 <em>调试</em>（debug）手段。什么？<code>print</code> 语句/函数？写 3 行代码可以，3 百行代码可以，但是 3 万行、3 千万行呢？手动添加调试代码的方式不仅缺乏交互性，还增加了工作量，需要在开发结束删除或者通过某种机制禁用（如 C 的 <code>DEBUG</code> 宏）。调试器就提供了这样的功能，能够在程序运行过程中实时监测变量的值，在代码中设立 <em>断点</em>（breakpoint）或 <em>观测点</em>（watchpoint），调试时动态显示这些值，再次提高工作效率。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGtPoD.png" alt="#b# VSCode 调试 Python" /></p><p>再者，代码写完需要构建成一个可以用的软件/项目，需要执行打包、压缩、加壳、添加水印、颁发证书等等操作，这些流程同样需要自动化；开发过程中，代码不是一成不变的，而是需要经过无数次的改动，每次改动之间的联系和关系需要管理；作为一个团队，需要共享一些配置和代码/库 …… 这一切的一切，都需要一堆工具和一套科学的方法体系来管理控制，IDE 就是这样一个工具集合，依据某些开发理论组合而成。</p><h3 id="编译器"><a class="markdownIt-Anchor" href="#编译器"></a> 编译器</h3><blockquote><p>编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。<br />主要的目的是将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序，也就是可执行文件<br />—— 万维百科</p></blockquote><p>对于 C/C++，编译器将源代码转换成可执行文件，其本质就是计算机指令的二进制表示，可以直接在操作系统上运行；对 Java，编译器将源代码转换成 Java 虚拟机（JVM）能运行的二进制指令。</p><p><em>编译原理</em> 是计算机专业的一门重要专业课，旨在介绍编译程序构造的一般原理和基本方法。内容包括语言和文法、词法分析、语法分析、语法制导翻译、中间代码生成、存储管理、代码优化和目标代码生成。编译原理是轮子哥（<a href="https://www.zhihu.com/people/excited-vczh" title="知乎个人主页">vczh</a>）所说的“计算机中的「三大浪漫」”，另两个是操作系统和图形学。</p><h4 id="静态和动态"><a class="markdownIt-Anchor" href="#静态和动态"></a> 静态和动态</h4><p>通常，静态类型的语言在 <strong>编译期间</strong> 检查数据类型，使用前必须声明数据类型，如 C/C++、C#、Java、Rust，通常需要编译。</p><p>而动态类型的语言通常不需要编译，<strong>运行期间</strong> 才做数据类型检查，源代码由 <em>解释器</em>（interpreter） 解释执行，因此叫 <em>解释型</em> 语言（相对于 <em>编译型</em>），如 JavaScript、Python、PHP，该类型的语言会在第一次赋值给变量时，在内部将数据类型记录下来。</p><h4 id="jit-和-aot"><a class="markdownIt-Anchor" href="#jit-和-aot"></a> JIT 和 AOT</h4><p>但实际上，JavaScript 是有编译过程的，但这又与传统的编译不同，不是提前编译整份文件，而是大部分情况在代码执行前编译，甚至是代码执行时编译（JIT，Just In Time），称为 <em>及时编译</em>。一个比较显著的现象就是变量/函数 <em>提升</em>（hoist）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">var</span> a<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正如上述 JS 代码，可以先赋值，再声明。如果一行一行解释执行的话，则无法预知在下方的声明。</p><p>相比于「编写-编译-执行」这一过程，运行时编译可以加快从编码到执行的时间，JVM 在运行时也用到了 JIT 技术。与 JIT 相对的就是 AOT（Ahead Of Time），运行前编译，比如普通的静态编译。</p><p>实际上，种种技术都是 <strong>速度</strong> 和 <strong>质量</strong> 博弈的结果，静态类型保证数据的可靠性，加快了执行速度，但降低了开发效率，动态类型提高了开发效率，但免不了数据出现错误，JIT 技术可以说是一个折中，但又会消耗运行时（runtime）资源。为了压榨性能，新兴的现代编程语言是多种技术的集合，是不能简单用几个标签就能归类的。</p><p>编程语言是以一种 <strong>规范</strong>，具有语法特性，每种语言都有各自对应的编译器/解释器，每款编译器/解释器的具体实现不一。对于 C/C++，VS 使用 MSVC，Linux 使用 <code>gcc</code>/<code>g++</code>，XCode 使用 <code>clang</code>/<code>clang++</code>；对于 Python，有使用 C 开发的解释器 <em>CPython</em>（最流行，<a href="https://www.python.org/">官网</a> 默认即为 CPython），有使用 Java 开发的 <em>JPython</em>，有使用 Python 开发的 <em>PyPy</em>。各种语言的实现都可以有，但每种编译器/解释器的实现方式和优化不尽相同，质量有高有低。</p><p>用 Python 开发 Python 的解释器，编程语言的这种行为称为 <a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)" title="Wiki"><em>自举</em></a>（bootstrap）。通常来说，一门新的编译型语言（假设为 NL）的编译器会使用其他语言（比如 C、C++、汇编）来开发，然后使用得到的编译器（如 CNL）编译编译器的源码，再逐步完善（得到使用 NL 开发的编译器 NLNL）。</p><p>既然提到了编译器，就不得不说 GCC 和 LLVM 了。</p><h4 id="gcc"><a class="markdownIt-Anchor" href="#gcc"></a> GCC</h4><blockquote><p><a href="https://gcc.gnu.org/">GNU</a>，GNU Compiler Collection，GNU 编译器套件。</p></blockquote><p>GCC 原为 <em>GNU C Compiler</em>，只能处理 C 语言。但其很快扩展，变得可处理 C++，后来又扩展为能够支持更多编程语言，如 Fortran、Pascal、Objective-C、Java、Ada、Go 以及各类处理器架构上的汇编语言等，所以改名 <em>GNU Compiler Collection</em>。</p><p>GCC 套件包括但不限以下工具：</p><ul><li><code>gcc</code>：运行该工具等同于执行编译链接生成等一系列过程</li><li><code>g++</code>：类似 gcc，默认语言设置为 C++</li><li><code>ld</code>：链接器</li><li><code>as</code>：GNU 汇编器，实际上是一族汇编器，可以编译为能在各个平台上工作</li><li><code>gdb</code>：GNU 调试器，一款强大的调试器</li><li><code>nm</code>：列出目标文件中定义的符号</li><li><code>make</code>：执行脚本的工具，C/C++ 开发时，通常使用 Makefile 编写好文件之间的依赖和关系，然后使用 <code>make</code> 执行时，将按照 Makefile 定义的顺序编译链接生成</li><li><code>objdump</code>：显示目标文件中保存的多种不同信息</li></ul><p>除此之外还有一系列库。</p><p>GCC 是一套组件的 <strong>集合</strong>（在此用大写标识），而 <code>gcc</code> 和 <code>g++</code> 实际上是 <strong>驱动器</strong>，根据文件特征或者参数调用相关工具和库，最终生成目标文件。详细区别可见 <a href="https://www.zhihu.com/question/20940822">gcc和g++是什么关系？ - 知乎</a>。</p><h4 id="llvm"><a class="markdownIt-Anchor" href="#llvm"></a> LLVM</h4><blockquote><p>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.<br />—— <a href="http://llvm.org/" title="主页">The LLVM Compiler Infrastructure</a></p></blockquote><p>LLVM 的命名最早来源于底层语言虚拟机（Low Level Virtual Machine）的缩写。它是一个用于建立编译器的基础框架，最初是伊利诺伊大学（<em>University of Illinois</em>）的一个研究项目，目标是提供一种现代的、基于 SSA 的编译策略，能够同时支持任意编程语言的静态和动态编译。自那时以来，LLVM 已经成为一个由若干子项目组成的总括项目，包括但不限于：</p><ul><li>LLVM Core：LLVM 核心库提供一个与源和目标无关的现代优化器，以及对许多流行 CPU 的代码生成支持，核心库是围绕 <em>LLVM IR</em>（LLVM 中间表示）构建的。</li><li>Clang：LLVM 原生的 C/C++/Objective-C 编译器</li><li>LLDB：建立在 LLVM 和 Clang 提供的库之上，提供一个优秀的调试器</li><li>LLD：一个新的链接器，取代系统链接器，运行速度更快</li><li><code>libc++</code> 和 <code>libc++ ABI</code>：提供了一个标准的、符合规范的、高性能的 C++ 标准库实现</li></ul><p>LLVM 跟 GCC 不是对应关系，后者是一个组件，而前者是一个编译器框架，一个最明显的体现在于 LLVM IR。不同于机器码，这是一种更低层（更接近机器），但尚未完全暴露出具体平台相关的特征的代码表示，因此具有通用性和可移植性。</p><p>各种各样的应用（DSL、GPU 数据库、TVM、安全、区块链等）<br />=&gt; 生成 LLVM IR<br />=&gt; 编写针对自己特定应用的优化<br />=&gt; LLVM 的优化<br />=&gt; LLVM 代码生成<br />=&gt; 目标代码（ARM、x86、Hexagon、NVPTX、AMDGPU、WebAssembly、定制的芯片等）</p><p>LLVM 是一个后端，C 和 Python 都可以编译成 LLVM IR，然后再进一步处理。这种模块化的组成降低了设计一款编程语言的难度。因此 LLVM 与底层虚拟机已风马牛不相及，只是一个名称而已。各种语言如 Go、Rust、Swift 都有基于 LLVM 的编译器前端。</p><h3 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h3><p>说完编译器（compiler），再谈一谈编辑器（editor）。编辑器就是写代码的工具，本质就是文本编辑器。文本编辑器是计算机软件中的一种，主要用于用来编写和查看文本文件。<em>Microsoft Word</em> 是文本编辑器吗？不是，它编辑和保存的文件是二进制文件，文本文件应由字符（可打印和不可打印）组成。下面列举一些文本编辑器。</p><h4 id="notepad"><a class="markdownIt-Anchor" href="#notepad"></a> Notepad</h4><p>Notepad 就是 Windows 系统 <code>C:\windows\system32\</code> 下的 <code>notepad.exe</code>，中文名为 <em>记事本</em>。代码的本质就是文本文件，使用它书写足矣。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGtSL6.jpg" alt="#b# 近 60 位鹅厂程序员对 Python 开发工具的偏好 - 原图来自网络" /></p><p>可是，为什么真正使用记事本的人少之又少呢？</p><p>表述开发、编程、代码等关键词时以及在公众号博客等文章的封面，我们能经常看到类似这样的图片：</p><p><img src="https://goss1.veer.com/creative/vcg/veer/612/veer-143481084.jpg" alt="#b# 图片来自网络" /></p><p><img src="http://pics.sc.chinaz.com/files/pic/pic9/201811/zzpic15036.jpg" alt="#b# 图片来自网络" /></p><p>最直接的感受就是深色背景下花花绿绿的字体，这种将代码着以不同色彩的行为叫做 <em>高亮</em>（highlight）。代码是有规律可循的，相同的语法结构应该高亮出来，方便辨认，这就是记事本等普通编辑器无法做到的，但又是代码编辑器需要完成的目标之一。不同的人有不同的喜好，因此产生了各种配色，大多数代码编辑器支持自定义配色，用户可以选择第三方调校好的主题或者自行搭配。</p><p>在此分享两个网站：</p><ul><li><a href="https://vscodethemes.com/">VSCodeThemes</a>：VSCode 主题市场，可自由选择</li><li><a href="https://tmtheme-editor.herokuapp.com/">TmThemeEditor</a>：自定义 Sublime Text 3 主题，其中也内置了著名主题，用户可以在此基础上修改</li></ul><p>此外还要搭配合适的编程字体（宋体实在太没辨识度了，<code>0O1il</code> 不分）。以下为 <em>异次元软件世界</em> 介绍的几款编程字体</p><ul><li><a href="https://www.iplaysoft.com/jetbrains-mono.html" title="文章页">JetBranson Mono</a><br /><img src="https://img.iplaysoft.com/wp-content/uploads/2020/jetbrains-mono/jetbrains_mono_banner.png!0x0.webp" alt="#b# 文章封面" /></li><li><a href="https://www.iplaysoft.com/cascadia-code.html" title="文章页">Cascaia Code</a><br /><img src="https://img.iplaysoft.com/wp-content/uploads/2019/cascadia-code/cascadia_banner.jpg!0x0.webp" alt="#b# 文章封面" /></li><li><a href="https://www.iplaysoft.com/mononoki.html" title="文章页">Mononoki</a><br /><img src="https://img.iplaysoft.com/wp-content/uploads/2016/mononoki/mononoki_banner.jpg!0x0.webp" alt="#b# 文章封面" /></li><li><a href="https://www.iplaysoft.com/programming-fonts-collection.html" title="文章页">其他推荐字体合集</a></li></ul><p>一个成熟的代码编辑器需要完成的目标还有 <strong>语法检测</strong>、<strong>风格检测</strong>、<strong>格式化</strong>、<strong>语法提示</strong> 和 <strong>自动补全</strong> 等。开发者们矢志不渝，致力于打造方便快捷高效的工具，帮助开发者们提升开发体验（DX，Develop eXperience）。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGYxQ1.png" alt="#b# 代码提示和语法检测，按回车可补全" /></p><p>目前使用比较多的编辑器非 Vim/Emacs 和 VSCode 莫属，下面简单谈谈。</p><h4 id="sublime-text"><a class="markdownIt-Anchor" href="#sublime-text"></a> Sublime Text</h4><blockquote><p>用“最性感的编辑器”书写崇高的文本</p></blockquote><p><img src="https://img.iplaysoft.com/wp-content/uploads/2012/Sublime-Text-2---_D09E/sublimetext.jpg!0x0.webp" alt="#b# 异次元软件世界介绍 ST 时的封面" /></p><p><a href="http://www.sublimetext.com/" title="主页">Sublime Text</a> 是闭源收费软件，但可以免费无限期试用（全功能），但某个时间段使用频率较高时会弹窗提示购买。<s>这才是良心软件，免费给予使用权，收费给予所有权。</s></p><p><img src="https://a.axihe.com//img/tools/sublimetext/2015-09-05_55ea6f675e6c4.jpg" alt="#b# Sublime Text 提示购买 - 图片来自网络" /></p><p>目前最新版本为 <code>3.x</code>。ST 很难开箱即用，需要进行一些基本配置，如果要求较高，还得深度定制。现代编辑器包括下面提到的几个都拥有插件机制，得益于 Package Control，使用命令面板即可安装插件，也可到 <a href="https://packagecontrol.io/" title="Package Control 插件市场主页">插件市场</a> 挑选。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGtCdO.png" alt="#b# Sublime Text 的插件市场" /></p><h4 id="vs-code-和-atom"><a class="markdownIt-Anchor" href="#vs-code-和-atom"></a> VS Code 和 Atom</h4><p>Atom 是 GitHub 的一个开源项目，五六年前较为盛行，使用 Electron 技术栈打造，相当于把浏览器搬到桌面，Web 前端技术栈发挥空间较大，但随之而来的就是体积臃肿和运行卡慢。</p><p>2015 年，微软发布并开源了 <a href="https://code.visualstudio.com/" title="主页">Visual Studio Code</a>，一款轻量级的代码编辑器，同样基于 Electron。作为 Atom 的后继者，由微软牵头打造，经过多年努力，性能和功能非 Atom 所能及。</p><p><img src="https://picb.zhimg.com/v2-847a0fe866f6afb66af967aedaa5d3cb_r.jpg" alt="#b# VS 的安装大小 - 来自知乎专栏，作者见水印" /></p><p>我们在谈到编辑器的时候总会说「轻量级」这个词，而 IDE 总会说重量级，原因前文已经说过，编辑器只不过是 IDE 中的一个组件。虽然 VSCode 只是个编辑器，但搭配上插件，匹敌 IDE 不是难事，无论功能上还是体量上。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGtFFe.png" alt="#b# VSC 和 ST3 体积对比，macOS 平台日常使用，数据仅供参考" /></p><p>同时打开速度上，ST 可以实现瞬开，但 VSCode 只能实现秒开，但比 IDE 快多了。我通常使用 ST 更改配置文件、临时查看代码，使用 VSCode 作为开发环境。</p><p>成也 Electron，败也 Electron，使用该框架，即使没有功能，打包后体积也需 100MiB 起步，但巨硬拥有全球顶尖的团队，不断压榨性能的同时，还在拓宽功能，形成了一个繁荣的生态系统，拥有庞大的插件市场。更多信息和玩法见 <a href="#vs-code">VSCode</a> 一节。</p><h4 id="其他编辑器"><a class="markdownIt-Anchor" href="#其他编辑器"></a> 其他编辑器</h4><p>文本编辑器千千万，在 Atom 和 VSCode 之前和之后，都涌现大量工具，其中不乏优秀作品。下面列举一部分。</p><ul><li><a href="https://www.editplus.com/">EditPlus</a><ul><li>30 天免费试用</li></ul></li><li><a href="https://notepad-plus-plus.org/">Notepad++</a><ul><li>这两个都是 XP 时代的 UI 风格</li><li>免费使用</li></ul></li><li><a href="https://www.notepadsapp.com/">Notepads</a><br /><img src="https://static.wixstatic.com/media/0fcd80_f13c96da960d491fa8862087ad614ce4~mv2.png/v1/fill/w_972,h_745,al_c,q_90,usm_0.66_1.00_0.01/1.webp" alt="Notepads App - 图片来自官网" /><ul><li>Fluent Design 现代化 UI</li><li>Windows UWP</li><li>开源在 <a href="https://github.com/JasonStein/Notepads" title="GitHub 仓库">GitHub</a>，可在 <a href="https://www.microsoft.com/zh-cn/p/notepads-app/9nhl4nsc67wm" title="Microsoft Store">微软商店</a> 下载</li></ul></li></ul><h4 id="请出-vim"><a class="markdownIt-Anchor" href="#请出-vim"></a> 请出 Vim</h4><blockquote><p>Vi IMproved</p></blockquote><p>Vim 压轴并不为过，这款诞生于上个世纪的编辑器，是 Linux 下的文本编辑器，是 Vi 命令的加强版，支持各大平台架构。</p><ul><li><em>gVim</em> 是 Vim 的图形化前端。跨平台</li><li><em>NeoVim</em> 是 Vim 的衍生，与 Vim 存在竞争关系</li></ul><p>关于 Vim，最著名的段子就是「如何退出」，这与其独特的编辑模式密不可分：</p><ul><li>Normal：普通模式，<kbd>Esc</kbd> 进入</li><li>Insert：插入模式，<kbd>I</kbd> 进入</li><li>Visual：可视模式，<kbd>V</kbd> 进入</li><li>Replace：替换模式，<kbd>R</kbd> 进入</li><li>命令行模式，<kbd>:</kbd> 进入</li></ul><p>退出使用命令模式：</p><ul><li><code>q</code> 退出</li><li><code>wq</code> 写入（保存）</li><li><code>q!</code> 不写入退出</li></ul><p>使用 <code>vim</code> 命令进入将得到一个黑色的窗口，很难想象这就是一个有力的开发工具。诚然，不经配置的工具，和记事本并无区别。得益于 VimScript 和 <a href="https://vimawesome.com/" title="插件市场">插件系统</a>，可玩性大大增强，VimScript 是一门基于 Vim 的语言，因此可以通过 Vim 和 Shell 命令操纵任何事物。<s>只有你想不到的，没有我 Vim 做不到的（逃</s></p><p>Vim 最新版本为 <code>8.x</code>，支持异步 API 和浮动窗口，这个古老的生产力工具同样具有很多新特性，分享一张我配置的 Vim 截图，主题为 <em>gruvbox</em>。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGtkJH.png" alt="#b# Vim 开发界面" /></p><h4 id="emacs-不服"><a class="markdownIt-Anchor" href="#emacs-不服"></a> Emacs 不服</h4><p>Emacs 跟 Vim 一样，也是元老级，足够强大，但我没有使用过，不好在此评判。<s>虽然没有用过，但必须拥有姓名（逃</s></p><h3 id="再谈-ide"><a class="markdownIt-Anchor" href="#再谈-ide"></a> 再谈 IDE</h3><p><s>关于 IDE 还没完，大 VS 和 JB 家族必须拉出来吹一下。</s></p><p>前面 <a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a> 一节提到，Visual Studio C++ 已被 <a href="https://visualstudio.microsoft.com/zh-hans/" title="主页">Visual Studio</a> 集成，不止是 C++，还有 Visual Studio Python、Visual Studio C# 等一系列组件，动辄十几 G，实际上客户端开发的 IDE，如 XCode 和 Android Studio，都需要大量依赖和库，体量是不会小的。</p><h4 id="jetbrains-必须拥有姓名"><a class="markdownIt-Anchor" href="#jetbrains-必须拥有姓名"></a> JetBrains 必须拥有姓名</h4><p><a href="https://www.jetbrains.com/" title="主页">JetBrains</a> 是一家很酷的公司，开发了一系列优质的 IDE，最出名的莫过于 <a href="https://www.jetbrains.com/idea/" title="IntelliJ IDEA主页">IntelliJ IDEA</a> 和 <a href="https://www.jetbrains.com/pycharm/" title="PyCharm 主页">PyCharm</a>。此外 <a href="https://kotlinlang.org/" title="主页">Kotlin</a> 语言也是 JB 家的。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGYzsx.png" alt="#b# JetBrains 主页" /></p><p>产品虽好用，但是收费，不过 IDEA 和 PyCharm 有可以免费使用的社区版；作为学生或教师，可免费使用所有产品；作为开发者，同样可以申请认证，从而免费使用所有产品。</p><h4 id="过气网红-eclipse"><a class="markdownIt-Anchor" href="#过气网红-eclipse"></a> <s>过气网红</s> Eclipse</h4><p>提到 Java 开发，<a href="https://projects.eclipse.org/projects/eclipse.platform" title="主页">Eclipse Platform</a> 拥有一席之地，该开源项目隶属于 <a href="https://www.eclipse.org/" title="主页">Eclipse 基金会</a>。Eclipse 是一个可扩展开发平台（platform），本身只是一个框架，通过插件来构建开发环境，所以可执行文件只有几 MiB。Eclipse 包括一个插件开发环境（Plug-in Development Environment，注意这个词，不是说开发插件的环境，而是环境由插件组成，环境是 <code>plug-in</code> 的。<s>原来英文也会有这个时候╮(╯▽╰)╭</s>）。官方提供了一个标准插件集，其中就包含 Java 开发包（<a href="https://projects.eclipse.org/projects/eclipse.jdt">Eclipse Java development tools(JDT)</a>），当然也有 C/C++（<a href="https://projects.eclipse.org/projects/tools.cdt">Eclipse C/C++ Development Tooling(CDT)</a>）等开发包。</p><p>因为这个项目是用 Java 开发的，所以……卡慢。<s>比 IDEA 还慢（IDEA 也是 Java 写的）。</s></p><h2 id="vs-全家桶"><a class="markdownIt-Anchor" href="#vs-全家桶"></a> VS 全家桶</h2><blockquote><p>“全家桶”这个称呼是我冠上的，实际上称为系列更合理。</p></blockquote><p><s>下面才是原本的文章</s></p><p><img src="https://s1.ax1x.com/2020/07/13/UGtVSA.png" alt="#b# VS 主页" /></p><h3 id="visual-studio"><a class="markdownIt-Anchor" href="#visual-studio"></a> Visual Studio</h3><p>众所周知，VS 是 Windows 上宇宙第一 IDE，不多说。</p><p><img src="https://s1.ax1x.com/2020/07/13/UGtZQI.png" alt="#b# Visual Studio Code 主页" /></p><h3 id="visual-studio-online"><a class="markdownIt-Anchor" href="#visual-studio-online"></a> Visual Studio Online</h3><p>北京时间 2019 年 11 月 4 日，在 Microsoft Ignite 2019 大会上，微软正式发布了 Visual Studio Online 公开预览版。</p><p>简单来说，VS Online 由两部分组成：</p><ul><li>前端：VS Code、VS 和 Web 版 VS Code（也就是 VS Online 提供的前端界面）</li><li>后端：由云服务支撑的开发环境，由 <a href="https://www.azure.cn/" title="主页">Azure</a> 提供有力支持</li></ul><p>本质上说，是一种 SaaS 服务，其实就是后端建立标准化的的开发环境，前端通过某些形式（PC 端软件、移动端软件、Web 页面）接入。</p><p>- 懂了吗？<br />- 懂了！<br />- 好！改名部上。</p><h3 id="visual-studio-codespaces"><a class="markdownIt-Anchor" href="#visual-studio-codespaces"></a> Visual Studio Codespaces</h3><p><img src="https://s1.ax1x.com/2020/07/13/UGtAWd.png" alt="#b# Visual Studio Codespaces" /></p><p>正如你所见，Visual Studio Online 现在称为 <a href="https://visualstudio.microsoft.com/zh-hans/services/visual-studio-codespaces/"><em>Visual Studio Codespaces</em></a> 啦。</p><p>了解了产品的本质，现在来说一说替代品。</p><ul><li>腾讯云的 <a href="https://coding.net/products/cloudstudio" title="主页">Cloud Studio</a><br /><img src="https://s1.ax1x.com/2020/07/13/UGt9eK.png" alt="#b# Cloud Studio 的特性" /><ul><li>是腾讯云旗下 Coding 的产品，Coding 本身就兼具代码托管、集成测试、CI/CD 等功能，将代码编辑上云，方便开发也不足为奇，使开发成为闭环</li></ul></li><li><a href="https://stackblitz.com/" title="主页">StackBlitz</a><br /><img src="https://s1.ax1x.com/2020/07/13/UGtdTU.png" alt="#b# StackBlitz 的 Web 界面" /><ul><li>在浏览器编写代码并实时预览，可连接到 GitHub 仓库</li><li>目前仅限前端技术栈</li></ul></li><li><a href="https://github.com/cdr/code-server" title="GitHub">Code Server</a><ul><li>部署好后直接使用地址访问即可，相当于自建的 StackBlitz</li></ul></li></ul><p>这些产品都具有一个特点，都是基于 Web 前端，在网页中写代码，打开浏览器即可。大多数都用了 Monaco Editor 这个基于网页的编辑器（见 <a href="#vs-code">VS Code</a> 一节）。</p><h3 id="visual-studio-code"><a class="markdownIt-Anchor" href="#visual-studio-code"></a> Visual Studio Code</h3><p>跟 VS 不同，VSCode 是轻量级的编辑器，千文介绍过了，后文将进一步讨论。</p><h3 id="visual-studio-code-remote"><a class="markdownIt-Anchor" href="#visual-studio-code-remote"></a> Visual Studio Code Remote</h3><p>Visual Studio Code Remote 是一系列 VSCode 的 <strong>插件</strong>，允许开发者将容器（container），远程计算机，或 Windows Subsystem for Linux (WSL) 作为完整的开发环境，插件分别如下：</p><ul><li><code>Remote - SSH</code>：通过 SSH 连接到远程计算机或者虚拟机，选择一个文件夹作为工作目录</li><li><code>Remote - Containers</code>：把 Docker 作为开发容器</li><li><code>Remote - WSL</code>：在 Windows Subsystem for Linux 中，获得 Linux 般的开发体验</li></ul><p>搜索 「Remote」 关键词时会出现 <code>Remote Development extension pack</code>，这是一个插件包，包含以上三个插件，一键下载即可全部安装。<s>第一次装的时候没看清，有点蒙圈。</s></p><h3 id="codespaces"><a class="markdownIt-Anchor" href="#codespaces"></a> Codespaces</h3><p>嗯？Visual Studio Codespaces 跟这个 <a href="https://github.com/features/codespaces" title="主页">Codespaces</a> 有什么关系？</p><p>没有直接关系，这是 GitHub 推出的服务，而不是微软的，尽管 GitHub 现已被微软收购。实际上如果没改名，可能就不那么容易搞混 <s>也许就是为这事儿改名的（逃</s></p><p><video width="650px" height="451px" loop autoplay playsinline muted type="video/mp4; codecs=avc1.4D401E,mp4a.40.2" src="https://github.githubassets.com/images/modules/site/codespaces/hero.h264.mp4"></video></p><p>从来自官网的动图看，这项服务可以在浏览 GitHub 仓库时一键进入该项目的工作目录，开始修改或阅读代码。</p><blockquote><p>How is Codespaces different from VS Code?<br />Codespaces sets up a cloud-hosted, containerized, and customizable VS Code environment. After set up, you can connect to a codespace through the browser or through VS Code.</p></blockquote><p>VS Codespaces 是将 VSCode 作为一个前端，这个功能网页也可以替代，其重点是后端的 Azure 云开发环境；而 GitHub Codespaces 是将 GitHub 网页作为唯一前端（Get the full Visual Studio Code experience without leaving GitHub.），其重点在 Web 页面，不离开 GitHub 网页就可以获得 VSCode 的开发体验。</p><h2 id="vs-code"><a class="markdownIt-Anchor" href="#vs-code"></a> VS Code</h2><p><s>终于开始点题了</s></p><h3 id="杰出特性"><a class="markdownIt-Anchor" href="#杰出特性"></a> 杰出特性</h3><p>微软集结了杰出工程师，汇聚全球开发者的智慧。其团队负责人 <em>Erich Gamma</em>，是：</p><ul><li>JUnit 作者之一</li><li>《设计模式》作者之一</li><li>Eclipse 架构师</li></ul><p>2011 加入微软，在瑞士苏黎世组建团队开发基于 Web 技术的编辑器，也就是后来的 <a href="https://microsoft.github.io/monaco-editor/" title="主页"><em>Monaco Editor</em></a>。VSCode 开发团队早期成员 10 来个人，但大多有 Eclipse 开发团队的背景。<a href="https://github.com/microsoft/monaco-editor" title="GitHub">Monaco Editor</a> 是基于 Web 的编辑器，从 VSCode 脱离出来，成为一个独立的项目。</p><p>VSCode 在短短几年内，超越了 Atom、Sublime Text、Vim，成为最受欢迎的代码编辑器。同时，其架构设计和开发理念将代码编辑器提升到一个新的高度，我认为称之「神话」并不为过（<a href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">推荐阅读</a>-3）。不得不说巨硬还是强，但凡用心。<s>改名部和大刀部笑了。不把一手好牌打烂就不叫微软（逃</s></p><p><img src="https://pic4.zhimg.com/v2-f06d2184194415c4581b872e68674408_r.jpg" alt="#b# 图片来自知乎" /><br /><img src="https://pic4.zhimg.com/v2-1a79eba389c1a66908c6b0262cdfe0bb_r.jpg" alt="#b# 图片来自知乎" /></p><p>目前 VSCode 已统治了前端开发，几乎所有前端开发者都在使用。产品本身好用是一回事，另一个原因是 VSCode 本身就是由前端技术栈打造，对 JS/TS 的支持度较高，除此之外还有更重要的一点就是前端技术纷繁芜杂，变化多端，五六年之间，从刀耕火种，完成了工程化，在大前端时代，很难找到一款适合每个团队的 IDE，相比之下，选择重要组件，辅以不同的配置项来搭建开发环境更为便捷。</p><p><img src="https://pic2.zhimg.com/v2-623a63be2fde7b549a3c471d48fc585b_r.jpg" alt="Erich Gamma 在 2017 SpringOne Platform 上分享对于 VSCode 的定位 - 来自知乎" /></p><h4 id="lsp"><a class="markdownIt-Anchor" href="#lsp"></a> LSP</h4><blockquote><p>Language Server Protocol</p></blockquote><p>用于语法提示，是 VSCode 的一大创举，传统语法提示基于语法结构，将代码转换成抽象语法树（AST，Abstract Syntax Tree）再解析，而 LSP 不再关注 AST 和 Parser，转而关注 Document 和 Position，从而实现语言无关。</p><p>将语言提示变成 CS 架构，核心抽象成当点击了文档的第几行第几列位置需要 Server 作出什么响应的一个简单模型，基于 JSON RPC 协议传输，每个语言都可以基于协议实现通用后端。</p><p><img src="https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/lsp-illustration.png" alt="#b# LSP" /></p><h4 id="dap"><a class="markdownIt-Anchor" href="#dap"></a> DAP</h4><blockquote><p>Debug Adaptor Protocol</p></blockquote><p>VSCode 的另一大创举，实现了一个基于抽象协议、通用的、语言无关的调试协议。该协议用于和调试器后端通信，但调试器没有实现该协议，因此需要一个中介（adaptor）来适配，该中介称为 <em>Debugger Adaptor</em>（DA），通常是一个独立进程。</p><p><img src="https://code.visualstudio.com/assets/api/extension-guides/debugger-extension/debug-arch1.png" alt="#b# DAP 架构示意 - 来自官方文档" /></p><p>这两大设计属于高屋建瓴，可以看出开发团队的思想层次，把自己的东西做成标准，做出生态，开放共赢。连 Vim 也开始兼容这些协议。</p><p>在其他方面，VSCode 的表现同样可圈可点，比如全文查找替换和全目录查找替换，且支持正则匹配，甚至做到毫秒级响应。</p><p><img src="https://code.visualstudio.com/assets/docs/getstarted/userinterface/hero.png" alt="#b# VSCode 界面组成" /></p><p>下面简单讨论几个常用功能点。<a href="https://code.visualstudio.com/docs/">官方文档</a> 有详细且权威的资料，更多信息请移步。</p><h3 id="工作区"><a class="markdownIt-Anchor" href="#工作区"></a> 工作区</h3><p>工作区由一个个标签组成，通常打开的是文本文件，但打开格式流行的图片也是可以的。</p><p><img src="https://code.visualstudio.com/assets/api/extension-guides/webview/basics-drag.gif" alt="#b# 来自 VSCode 文档" /></p><h3 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h3><p>VSCode 提供了两种设置方式：GUI 和配置文件。在之前也跟 ST 和 Atom 一样都是编辑配置文件，现在 Atom 和 VSCode 都引入了图形化的配置方式。</p><p><img src="https://code.visualstudio.com/assets/docs/getstarted/settings/settings.png" alt="#b# VSCode 设置 GUI" /></p><p>每个插件都可以有自己的配置项，在不明确配置项或者读完文档之前，难以下手进行配置，通过图形界面可以展示每个项目。通过复选框、下拉列表和输入框，完成了大多数配置要求。</p><ul><li>鼠标掠过配置项左侧，将浮现一个齿轮 ⚙，点击可复制该项到 JSON 文件。</li><li>单击标签栏右上角「打开设置」的图标，即可打开 <code>settings.json</code> 配置文件。</li></ul><h3 id="插件系统"><a class="markdownIt-Anchor" href="#插件系统"></a> 插件系统</h3><p>这也是其他编辑器共有的特性，没有插件，就变成了记事本和 VS（要么过弱要么过强）。但不同于 ST 和 Vim，VSCode 是开箱即用的，下载安装就能上手简单的开发，这实际上是由内置插件实现的，VSCode 内部功能也是插件化独立的。（VSCode 将模块化做到极致，甚至连图标都整合一套并开源了。）</p><p>官方为几种语言提供了插件和开发包，可直接安装使用（当然要在准备好开发依赖的前提下）。</p><p><img src="https://code.visualstudio.com/assets/docs/editor/extension-gallery/extensions-view-icon.png" alt="#b# Activity Bar 上的「扩展」图标 - 图片来自官方文档" /></p><p>点击左侧的扩展图标，搜索栏自动获得焦点，在此可以检索相关插件，点击可查看插件详情，打开为一个不可编辑标签。</p><p><img src="https://code.visualstudio.com/assets/docs/editor/extension-gallery/extensions-popular.png" alt="#b# 搜索查看插件 - 图片来自官方文档" /></p><p>如下图，Go 语言的插件由 Microsoft 开发，这些主流语言的插件都由官方提供并维护。</p><p><img src="https://code.visualstudio.com/assets/docs/editor/extension-gallery/extension-contributions.png" alt="#b# 点击查看插件详情 - 图片来自官方文档" /></p><h3 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h3><p>高效的工作流离不开快捷键的加持。VSCode 支持自定义快捷键，结合插件，可以引入 ST、Atom、VS 等编辑器的快捷键方案，同样这些插件也由官方提供。</p><p><img src="https://code.visualstudio.com/assets/docs/getstarted/keybinding/keyboard-shortcuts.gif" alt="#b# 快捷键编辑" /></p><p>以下为三大平台上默认快捷键映射表：</p><ul><li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="PDF">Windows</a></li><li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf" title="PDF">macOS</a></li><li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf" title="PDF">Linux</a></li></ul><h3 id="集成终端"><a class="markdownIt-Anchor" href="#集成终端"></a> 集成终端</h3><p>VSCode 集成了终端，默认按 <kbd>Ctrl</kbd> + <kbd>`</kbd> 切换，可以开启多个会话。类似 VS，VSCode 将问题、输出和终端分开，又引入了调试控制台，使得调试过程中能够交互式（REPL，Read-Eval-Print Loop）查看变量，执行相关语句。</p><p><img src="https://code.visualstudio.com/assets/docs/editor/debugging/debugconsole.png" alt="#b# 调试控制台 - 图片来自官方文档" /></p><h3 id="命令面板"><a class="markdownIt-Anchor" href="#命令面板"></a> 命令面板</h3><p><kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>F</kbd> 可唤出命令面板，在此可输入并执行一些命令，快捷键的本质也就是绑定这些命令。</p><ul><li>以 <code>&gt;</code> 为提示符是执行命令：<kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd>，Windows 下为 <kbd>Ctrl</kbd></li><li>以 <code>:</code> 为提示符是跳转到当前文件某行：<kbd>Ctrl</kbd> + <kbd>G</kbd></li><li>以 <code>@</code> 为提示符是跳转到当前文件的某个结构：<kbd>Cmd</kbd> + <kbd>Shift </kbd> + <kbd>O</kbd>，Windows 下为 <kbd>Ctrl</kbd></li><li>没有提示符是打开当前工作目录的文件：<kbd>Cmd</kbd> + <kbd>P</kbd>，Windows 下为 <kbd>Ctrl</kbd></li></ul><p>以上功能仅仅是 VSCode 强大功能的冰山一角，</p><p>每年，开发团队会发布一个 Roadmap，表示接下来一年要做的工作，每个月 VSCode 都会发布一个新版本，每次更新都会打开一份发行声明（「帮助-发行声明」也可以查看），详细描述更新的新功能和预览版功能（已经做完的和做好了的），每次通读都会感叹 VSCode 实在是太强大了。如果能读完每一篇发行声明，那必定会对这款软件产生更深刻的理解，可惜我目前做不到-_-。</p><p>多翻翻文档和设置，每次指定会有新收获。比如「Developer: Toggle Screencast Mode」命令，启用后每次按键、每次点击都会在窗口内标识，用于截图和录屏演示的场景。</p><p><img src="https://code.visualstudio.com/assets/updates/1_31/screencast.gif" alt="#b# Screencast 模式，2019.1 发行说明  - 图片来自官方文档" /></p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>肝了两天，这篇难产的文章终于告一段落了，行文至此，应该可以摆脱内容太浅的问题了，起码足够广。<s>虽然也很水。</s></p><h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2><ol><li><a href="https://code.visualstudio.com/docs">Visual Studio Code 官方文档</a></li><li><a href="https://blog.csdn.net/xtlisk/article/details/39099199">AOT和JIT - CSDN</a></li><li><a href="https://www.zhihu.com/question/38355661/answer/76067276">编译器是如何编译自己的？ - RednaxelaFX的回答</a></li><li><a href="https://zhuanlan.zhihu.com/p/96041706">从 VSCode 看大型 IDE 技术架构 - paranoidjk的文章</a></li><li><a href="https://www.zhihu.com/question/363365943">Visual Studio Code 可以翻盘成功主要是因为什么？ - 知乎</a></li></ol><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/90094288">重磅！微软发布 Visual Studio Online：Web 版 VS Code + 云开发环境</a></li><li><a href="https://zhuanlan.zhihu.com/p/64505333">VS Code Remote 发布！开启远程开发新时代</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 参考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 与 SPA 部署</title>
      <link href="2020/02/github-yu-spa-bu-shu/"/>
      <url>2020/02/github-yu-spa-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近在写一个 <a href="https://en.wikipedia.org/wiki/Single-page_application" title="Wiki">单页面应用</a>，用来练习 <a href="https://redux.js.org/" title="主页">Redux</a>，其中用到了 <a href="https://reacttraining.com/react-router/" title="主页">React Router</a> 库，<s>实际开发过程中，Redux 用的挺顺手，Router 反而不会用了。</s> 采用前后端分离的方式。本地调试一直都是起一个 devServer，写完了登录页，扔给后端同学测一下，却反馈说双击打开一片空白。</p><p>确实，我之前使用 Router 库，预览的时候也是不能直接打开，因为路径问题，我默认 <code>/</code> 为主页，因此 <code>file:///xxx/index.html</code> 这个 URL 显然不匹配，而 <code>index.html</code> 文件是有效的，只是 JS 处理路由的代码没执行而已，因此使用服务器，默认访问 <code>/</code> 就是 <code>index.html</code>，就忽略了 URL 差异。</p><h2 id="file"><a class="markdownIt-Anchor" href="#file"></a> <code>file:///</code></h2><p>先来看一下 file，在电脑上双击 HTML 文件，可以在浏览器打开，访问其页面，有很多应用如 <a href="https://merricx.github.io/qrazybox/" title="主页">QRazyBox</a> 就是这样做到离线使用。</p><p>其实这是一个协议，就如同 HTTP 协议：</p><pre class="line-numbers language-none"><code class="language-none">protocol :&#x2F;&#x2F; hostname[:port] &#x2F; path &#x2F; [;parameters][?query]#fragment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而需注意，<em>file</em> 是三条 <code>/</code>，Google Chrome 默认不显示协议名称，将地址栏的内容复制出来则会自动加上。为什么是三条 <code>/</code> 呢，这要看 <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" title="Wiki">URI</a> 的定义：</p><pre class="line-numbers language-none"><code class="language-none">scheme : [&#x2F;&#x2F;[user:password@] host [:port]] [&#x2F;] path [?query] [#fragment]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以 <code>https://www.zhihu.com/question/37063799</code> 为例，<code>www.zhihu.com</code> 是 <em>host</em>（主机名）， 后面的属于 <code>path</code>，而如果是本地文件，<em>host</em> 部分就不需要了，所以合起来就变成了 <code>///</code>，但根据 <code>[]</code>，其实两个 <code>//</code> 都应该省略的。</p><p>再看 <em>file</em> 协议，它是用于访问本地计算机中的文件，就如同在 Windows 资源管理器中打开文件一样，注意它是针对本地（本机）的，简单说，file 协议是访问本机的文件资源。</p><pre class="line-numbers language-none"><code class="language-none">file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;Admin&#x2F;file.avi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就相当于</p><pre class="line-numbers language-none"><code class="language-none">C:&#x2F;Users&#x2F;Admin&#x2F;file.avi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问本地 HTML，其实是在本地起了一台 HTTP 服务器，然后访问电脑上的本地服务器，HTTP 服务器再去访问本机的文件资源。<br />曾经虚拟机玩的不熟，增强工具总是安装失败，就考虑通过网络来共享文件，在 Ubuntu 里成功部署过 SMB 服务器，然后通过 Windows 下的资源管理器访问，在地址栏输入 <code>\\192.168.1.1</code> 访问，就可以像在本机一样操作 <s>远程</s> 主机，如同局域网共享（实际上本来就是，Windows 支持很多共享协议）。</p><p>在浏览器的地址栏输入 <code>file:///</code> 就可以看到本机的文件（目录）了，有点类似 FTP 站点。</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQHTf.png" alt="#b# 访问本地文件" /></p><p>再回到 <em>file</em> 协议打开 HTML 的问题，访问 <code>index.html</code>，会引入该文件需要的静态文件，而如果脚本文件又引入（<code>import</code>）了其他文件，在这里则是无效的，我们可以做个实验：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写上述脚本命名为 <code>test.js</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> test <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./test"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再在以上代码内引用，保存并命名为 <code>main.js</code>，通过 <code>&lt;script&gt;</code> 插入到一份 HTML 文件，访问就可以得到一个 Error：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQ4ld.png" alt="#b# 加载失败" /></p><p><s>Chrome 显然已经支持了很多 ES6 语法。</s> 加载 <code>test.js</code> 需要服务器解析并返回，所以开发者工具的 Source 以及 Network 会有一堆文件（当然，ES6 以及 JS 模块的原理还是很深奥，这里不深入了），<em>file</em> 协议这里仅是静态的访问，就跟资源管理器（或 Finder）里打开一样，无法参与解析。当然，不引用外部文件，或者直接在 HTML 文件里，JS 脚本是可以执行的。</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQ56A.png" alt="#b# 直接执行" /></p><p>那么既然了解了直接打开文件的原理，又该如何处理前言这个问题呢？理论上，直接浏览器打开文件是可行的，毕竟 React 只有一个 HTML 和一个 JS（当然也可以有多个），我没用 Router 库之前也是直接打开的，<s>对，用了之后就不行了。</s> 在我没有意识到我可以修改路由之前，我进行了一些 <s>搜索</s> 尝试。</p><h2 id="spa"><a class="markdownIt-Anchor" href="#spa"></a> SPA</h2><p>众所周知，SPA 这个概念是比较新的，在大前端时代，新概念、新技术层出不穷，SPA、MPA、PWA、SSR、Hybrid、Native，<s>这几个名词并不具有一定的关系</s> 可以引出宽广的技术栈。</p><p>SPA 就是单页面应用，只有一个 HTML 页面，原理类似点击一个按钮通过 JS 的 DOM 操作创建一个节点然后显示出来，但可以更改地址栏的 URL，然后 JS 通过 URL（History）的变化渲染对应组件，不同于动态网站，浏览器 URL 怎么变都跟服务器无关（实际上这就是静态网页）。</p><p>是吗？似乎不全是，React Router 切换路径不会发送请求，还是当前的 HTML（以及 JS）处理这个 URL（即 <em>前端路由</em>），但是一刷新，或者不是访问 <code>/</code>（或者 <code>index.html</code>），而是访问 <code>/home</code>（假如网页有该路径），实际上这两者是一个效果，都是向服务器请求 <code>/home</code>，但前面提到，URL 变化跟服务器无关，服务器哪认得这个 URL，<s>我静态网页只托管 <code>index.html</code>，其他的没有</s>，一个 404 打发回去，这与通常的动态网页不同，后端是不匹配（实际上是没有）路由的。</p><h2 id="spa-部署"><a class="markdownIt-Anchor" href="#spa-部署"></a> SPA 部署</h2><p>所以，问题很明显了，SPA 需要专门的部署方式。后端采用 Tomcat，带入关键词一搜，果然圈内普遍存在这种部署问题。前端路由的问题，React Router 和 Vue Router 都会遇到，解决方案很简单，使用 Node.js 服务器即可（逃</p><p>这并不能解决问题，我调试用的就是基于 Express 的 devServer，刷新或者热更新就找不到了（<s><code>historyApiFallback</code> 无效，因为有一个基地址</s>），需要手动更改 URL。搜索结果更多的是使用 <strong>重定向</strong> 来解决，将后端未知的 URL 请求重定向回去（即还是交给 <code>index.html</code> 处理），就可以了。</p><h3 id="nginx"><a class="markdownIt-Anchor" href="#nginx"></a> Nginx</h3><p>Nginx 作为高性能服务器，静态资源托管的大哥，转发流量是不在话下，<code>server</code> 块只需要加一句处理 fallback。</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">server_name</span>  www<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    <span class="token keyword">root</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>html<span class="token operator">/</span>spa<span class="token punctuation">;</span>    <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html<span class="token punctuation">;</span>    <span class="token keyword">location</span> <span class="token operator">~</span> <span class="token operator">^</span><span class="token operator">/</span>favicon\<span class="token punctuation">.</span>ico$ <span class="token punctuation">&#123;</span>        <span class="token keyword">root</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>html<span class="token operator">/</span>spa<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try_files</span> <span class="token variable">$uri</span> <span class="token variable">$uri</span><span class="token operator">/</span> @fallback<span class="token punctuation">;</span>        <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html<span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   Host             <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   X<span class="token operator">-</span>Real<span class="token operator">-</span>IP        <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For  <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span>   X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>Proto  <span class="token variable">$scheme</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">location</span> @fallback <span class="token punctuation">&#123;</span>        <span class="token keyword">rewrite</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">*</span>$ <span class="token operator">/</span><span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">access_log</span>  <span class="token operator">/</span>mnt<span class="token operator">/</span>logs<span class="token operator">/</span>nginx<span class="token operator">/</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tomcat"><a class="markdownIt-Anchor" href="#tomcat"></a> Tomcat</h3><p>后端主 Java 技术栈，使用 Tomcat 部署。对于汤姆猫，需要在 <code>web.xml</code> 文件设置 404 页面。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>404<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/spa/index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="apache"><a class="markdownIt-Anchor" href="#apache"></a> Apache</h3><p>Apache httpd 是修改 <code>httpd.conf</code>。</p><ol><li>打开 <code>mod_rewrite.so</code> 模块，取消注释 <pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">LoadModule rewrite_module modules/mod_rewrite.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改 <code>AllowOverride</code> 选项，将 <code>None</code> 改为 <code>All</code> <pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">AllowOverride All<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>建立 <code>.htacess</code> 文件放入网站文件夹（也可以在 <code>httpd-vhosts.conf</code> 文件中设置） <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IfModule</span> <span class="token attr-name">mod_rewrite.c</span><span class="token punctuation">></span></span>RewriteEngine OnRewriteBase /RewriteRule ^index\.html$ - [L]RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . /index.html [L]<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>IfModule</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="github-pages"><a class="markdownIt-Anchor" href="#github-pages"></a> GitHub Pages</h2><h3 id="静态网页"><a class="markdownIt-Anchor" href="#静态网页"></a> 静态网页</h3><p>倒腾了很久，后来意识到我可以修改路由，不必让首页匹配 <code>/</code>，就是说，<s>是我编码问题，跟 SPA 关系不大。</s> 使其跟普通页面一样，一进入就有内容，这样首先能解决点击空白的问题，再搭配服务器重定向的策略，就能解决刷新返回 404 的问题，如此，即可实现正常访问了。</p><p>很好，但是我每一个逻辑页面都有在判断路由，这样一改，首页就没法判断了，这时候，就用到了 <s>（学到了）</s> React Router 一个组件，<a href="https://reacttraining.com/react-router/web/api/withRouter" title="文档"><code>&lt;withRouter /&gt;</code></a> 高阶组件，把 <code>location</code>、<code>history</code>、<code>match</code> 等路由组件才有的信息注入普通组件，这样，首页就也能判断路由了。完美解决问题。</p><p>于是，我的 SPA 跟普通静态网页彻底一致了，既然是静态页面，就可以托管在 <strong>GitHub Pages</strong> 上，如此一来，可以实现真正的前后端分离，不必配置汤姆猫了。<s>（但会带来跨域问题。）</s></p><h3 id="静态网站生成器"><a class="markdownIt-Anchor" href="#静态网站生成器"></a> 静态网站生成器</h3><p>我们都知道，Github 提供了 <a href="https://help.github.com/en/github/working-with-github-pages" title="文档">GitHub Pages</a> 服务，用于项目展示，Geek 们利用这个特性可以制作个人主页、搭建博客，于是涌现了很多网站生成器，如 <a href="https://hexo.io/zh-cn/" title="主页">Hexo</a>、<a href="https://gohugo.io" title="主页">Hugo</a>，还有官方推荐的基于 Ruby 的 Jekyll 等等。</p><p>这些工具都有一个特点，生成的网页都是静态的，因为 GitHub Pages 只能托管静态网页。对于动态网页，言必及 WordPress，使用 WordPress 是需要自己准备服务器的。而不同于服务端组织页面来返回，静态页面是直接托管在服务器上已存在的内容，访问就能得到。静态网站生成器的作用，就是帮助用户 <strong>生成好所有页面</strong>，这样上传到服务器（Github）就能直接访问。</p><p>使用 GitHub Pages 搭建个人博客，我们都知道是建立一个 <strong>以用户名命名</strong> 的仓库，形如 <code>&lt;user&gt;.github.io</code>，开启了 GitHub Pages，然后即可通过 <code>http(s)://&lt;user&gt;.github.io/</code> 访问。</p><p><img src="https://help.github.com/assets/images/help/pages/create-repository-name-pages.png" alt="#b# 图片来自官方文档" /></p><p>每个项目都可以启用 GitHub Pages。经常可以看到一些网站的 URL 类似 <code>http(s)://&lt;user&gt;.github.io/&lt;repo&gt;</code>，比如 Element for React：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQ70P.png" alt="#b# Element-React" /></p><p>通常一个仓库 Setting 页的 GitHub Pages 设置如下：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DlC7V.png" alt="#b# 普通仓库的 GitHub Pages" /></p><p>能够看到，可以选用当前 Repo 的 <code>master</code> 分支托管网站，也可以使用 <code>master</code> 分支的 <code>docs</code> 文件夹。实际上不一定需要托管在主分支。当 Repo 设立了 <code>gh-pages</code> 分支，Github Pages 的 Option 会多出来该分支：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQjpQ.png" alt="#b# 设立了 gh-pages" /></p><p>再看 Element-React 项目的 Github：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQqk8.png" alt="#b# Element-React 的 gh-pages 分支" /></p><p>根据 <a href="https://help.github.com/en/github/working-with-github-pages/about-github-pages" title="官方文档">官方文档</a>，个人站点和组织站点是类似的，默认使用 <code>master</code> 分支，项目站点默认使用 <code>gh-pages</code>，也可以使用 <code>master</code> 分支或 <code>master</code> 分支上的 <code>/docs</code> 文件夹。</p><h3 id="404-not-found"><a class="markdownIt-Anchor" href="#404-not-found"></a> 404 Not Found</h3><p>这样就好了吗？正如标题所云，还没解决 SPA 刷新造成 404 的问题，如果是被请求的服务器可以将请求重定向回 <code>index.html</code>，但静态网站访问之后，资源找不到就是找不到。所以 GitHub 提供了 <a href="https://help.github.com/en/github/working-with-github-pages/creating-a-custom-404-page-for-your-github-pages-site" title="官方文档">自定义 404 页面</a> 的功能，找不到资源时，会搜索 <code>404.html</code> 或 <code>404.md</code>，Geek 们可以自定义样式和内容。</p><p>同样，针对 SPA 的路由，知乎有这样一个 <a href="https://www.zhihu.com/question/64173754" title="知乎">问题及回答</a>：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQzXn.png" alt="#b# 知乎问答" /></p><p>题主及答主给出了几种修复 URL 的方案：</p><ol><li>通过 sessionStorage 存储之前的地址，然后跳转到新地址里并读取之前存储的内容，重新 route</li><li>把当前地址作为参数跳转到 <code>index.html</code></li><li>复制 <code>index.html</code> 到 <code>404.html</code> 最简单粗暴，不过没准效果是最好的</li><li>让 <code>404.html</code> 直接获取 <code>index.html</code>，然后直接把它丢到文档流里</li></ol><p>最初我使用了 Hack 的方法，在 <code>404.html</code> 读取 <code>windwos.location</code>，修改 URL，将路径变为哈希字符串，然后使用  <code>history.replaceState()</code> 跳转到 <code>index.html</code>，主页检测 URL 再还原回来，但是效果不理想。<s>应该是我编码（不对，思路）问题。</s> 最后直接复制 <code>index.html</code> 为 <code>404.html</code>，试下来，真应了这句话：</p><blockquote><p>最简单粗暴，不过没准效果是最好的……</p></blockquote><p>故而，假使不好处理 404 的问题，不妨也复制一份 index 文件，立竿见影。</p><h2 id="github-actions"><a class="markdownIt-Anchor" href="#github-actions"></a> GitHub Actions</h2><p>使用 GitHub Pages 托管静态网站最简单的方法，就是在 <code>master</code> 分支上创一个 <code>/docs</code> 文件夹，然后 <code>build</code> 出文件，随源代码提交，即可热更新，非常酷炫。</p><p>这还不够酷，<a href="https://github.com/features/actions" title="主页">GitHub Actions</a> 了解一下。GitHub Actions 是 GitHub 的 <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" title="阮一峰的博文">持续集成</a> 服务，于 2018 年 10 月推出。官方是这样描述的：</p><blockquote><p>GitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.</p></blockquote><p>对于一个项目来说，写完代码还没完事，还要经过测试、部署等等一系列工作，这是正常流程，但每次提交、修复 bug 或者添加新特性，都要走一遍这样的流程，自然会觉得烦。“重复 3 次以上的工作都要用程序来自动化”，因此有了 <a href="https://travis-ci.org" title="主页">Travis</a>、<a href="https://pre-commit.com/hooks" title="主页">Pre-commit Hooks</a> 等工具，帮助开发者实现部分自动化，很多 Repo 里都有类似 <code>.travis.yml</code> 的文件。自从 GitHub 推出了 Actions 功能，这一历史就将改写，因为从代码提交到部署上线这一过程更加原生，一条龙服务 <s>，如果不用 Github，那就当我没说</s>。（对，Github 不只是托管代码，当然，GitLab、Gitee 也都在积极提出 CI/CD 和 DevOps 产品，以适应现代开发理念，更好的迎合市场需求。）</p><p>简而言之，Github Actions 就是提供一个环境，在某些条件下，可以执行一些操作。这个条件（配置文件的 <code>on</code> 字段）可以是 <code>push</code>、<code>issue</code>、PR 或是其他；执行的操作可以是编译、测试、fork、commit、发布等等，只要有配置文件，就能自动执行；所运行的环境可以是 Linux、Windows 以及 macOS（对，macOS 也支持，不过限制更多一点），硬件如下：</p><ul><li>2-core CPU</li><li>7 GB of RAM memory</li><li>14 GB of SSD disk space</li></ul><p>也可以自建环境（self-hosted），比如自己的树莓派（self-hosted runner）。借助 GitHub Actions，作为个人开发者我们可以实现每次提交源码，自动测试编译打包，然后发布到自己的平台（VPS 或者 GitHub Pages），当然 Geek 的想象力是无限的，Actions 能做的远远不止于此。</p><p>该功能入口在此：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQIOI.png" alt="#b# GitHub Actions" /></p><p>据 <a href="https://help.github.com/cn/actions/automating-your-workflow-with-github-actions">文档</a> 所述，Action 有以下几个概念：</p><ol><li><em>workflow</em>：持续集成运行一次的过程，就是一个 workflow</li><li><em>job</em>：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。多个 job 是并发执行的</li><li><em>step</em>：每个 job 由多个 step 构成，一步步完成，因此可以指定顺序（即依赖关系：<code>needs</code> 字段）</li><li><em>action</em>：每个 step 可以依次执行一个或多个命令（action）</li></ol><p>workflow 想必各位有点耳熟，iOS 上的 App <a href="https://apps.apple.com/cn/app/id915249334">捷径</a> 被收购前就叫 <em>Workflow</em>，产品如其名，可以自动化处理一些操作，Actions 也一样。</p><h3 id="actions-加持"><a class="markdownIt-Anchor" href="#actions-加持"></a> Actions 加持</h3><p>所以我盘算使用 GitHub Actions 来自动部署我的 SPA。Actions 的配置文件存放在 Repo 根目录的 <code>./github/workflow</code> 文件夹下，使用 YAML 语法配置。关于配置项，官方文档给的很详细，还提供了了编辑器，各位大牛的教程也很到位，这里不再赘述。以下是我这个项目的 workflow：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">name: SPA Deployeron:  push:    branches:      - masterjobs:  build-deploy:    runs-on: ubuntu-18.04    steps:      - uses: actions&#x2F;checkout@v1      - name: Setup Node        uses: actions&#x2F;setup-node@v1        with:          node-version: &#39;10.x&#39;      - run: yarn install      - run: yarn release      - name: Deploy        uses: peaceiris&#x2F;actions-gh-pages@v2        env:          ACTIONS_DEPLOY_KEY: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125;          PUBLISH_BRANCH: gh-pages          PUBLISH_DIR: .&#x2F;public&#x2F;release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用自己指定的 <code>yarn release</code> 命令，将文件编译到 <code>./public/release</code> 文件夹。用到了如下 Actions：</p><ol><li><a href="https://github.com/marketplace/actions/checkout" title="Marketplace">actions/checkout</a><ul><li><a href="https://github.com/actions/checkout" title="GitHub">GitHub</a></li><li>切换分支，即拉取代码</li></ul></li><li><a href="https://github.com/marketplace/actions/setup-node-js-for-use-with-actions" title="Marketplace">actions/setup-node</a><ul><li><a href="https://github.com/actions/setup-node" title="GitHub">GitHub</a></li><li>安装 Node.js，此后即可使用 Node 命令</li><li>同样支持 Yarn，之前我以为不支持，还找了另外的 actions：<a href="https://github.com/marketplace/actions/github-action-for-yarn" title="Marketplace">GitHub Actions for Yarn</a></li></ul></li><li><a href="https://github.com/marketplace/actions/github-pages-action" title="Marketplace">actions-gh-pages</a><ul><li><a href="https://github.com/peaceiris/actions-gh-pages" title="GitHub">GitHub</a></li><li>主角。部署项目到 <code>gh-pages</code> 分支（其他分支也可）</li><li>注意 <code>env</code> 的 <code>ACTIONS_DEPLOY_KEY</code> 是 SSH 私钥</li><li>具体操作见 <a href="https://github.com/peaceiris/actions-gh-pages/blob/master/README.md" title="GitHub README">README</a></li></ul></li></ol><p>至此，SPA 项目可以实现在 GitHub 上提交后自动构建并发布，与后端彻底分离。</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>试错阶段失败了很多次，最后终于成功了。</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQTmt.png" alt="#b# 构建失败" /></p><p>通过这一系列部署，学到了很多操作。运维不同于开发，求稳而不求变，遵循一定的流程，难怪需要大量自动化脚本，继而又涌现了大量 Docker、K8S 等自动化部署工具和 <a href="https://jenkins.io/" title="主页">Jenkins</a> 等持续集成工具。<strong>技术改变世界</strong>，相信使用脚本刀耕火种的日子不复存在。</p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://juejin.im/post/5dc4ae67f265da4cfa7bbb9a">前端部署发展史</a></li><li><a href="https://jsonz1993.github.io/2019/12/github-actions/">用github actions部署你的应用(hexo)</a></li><li><a href="https://help.github.com/cn/actions/automating-your-workflow-with-github-actions">Github Action 文档</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 C 语言指针二三事</title>
      <link href="2020/01/guan-yu-c-yu-yan-zhi-zhen-er-san-shi/"/>
      <url>2020/01/guan-yu-c-yu-yan-zhi-zhen-er-san-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>学习 C 语言到现在已经一年了，自从部署好 DPDK 到现在也过去了半年，但是对 DPDK 的学习却半点都没有深入，虽然主观上时间、魄力、方法这三者没有到位，但从客观上讲，掌握 C 语言尤其是指针实属不易，不过这也足够吸引人。</p><p>大概半年前，学习了 UNIX 环境下的 C 编程，才窥见这门古老语言的魅力。此后与人谈及就说 C 语言由宏和结构体组成，通过指针相互操作。有一次了解到 <a href="http://nginx.org/" title="Nginx 主页">Nginx</a> 里四级指针满天飞，惊诧于战斗民族的剽悍之风。再者，封面的代码，又该如何解释？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>既知指针是过不去的坎，最近发现几本 C 指针和 C 现代编程方法的书，就此又将学习 C 语言提上日程，本篇文章权当读书笔记以及感悟。</p><h3 id="标准"><a class="markdownIt-Anchor" href="#标准"></a> 标准</h3><p>C 语言标准有很多，<a href="https://www.sourcetrail.com" title="Sourcetrail 主页">Sourcetrail</a> 居然给出了这么多版本：</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjG59.png" alt="#b# C 标准的版本" /></p><p>总的来说，C 语言经历了如下发展：</p><ol><li><p><em>K&amp;R C</em>：1972 年，<em>Dennis Ritchie</em> 改进了 <a href="https://en.wikipedia.org/wiki/B_(programming_language)" title="Wiki">B 语言</a>，被称为 <em>NB</em>（New B），又称 <em>K&amp;R C</em></p></li><li><p><em>ANSI C</em></p><ol><li>1989 年，ANSI 推出 ANSI C 的 89 版标准</li><li>1990 年，ISO 推出 ISO C90</li></ol><p>实际上，<em>ISO C90</em> 和 <em>ANSI C89</em> 是同一个规范，因为 ISO 采纳了 ANSI C。由于 ANSI 早于 ISO 推出，因此通常称这个版本为 <em>ANSI C89</em></p></li><li><p><em>C99</em>：2000 年 3 月，ANSI 采纳了 <em>ISO/IEC 9899:1999</em> 标准，称为 <em>C99</em></p></li><li><p><em>C11</em>：2011 年由 <em>ISO/IEC</em> 发布，C 语言标准的第三版，也被称为 <em>C1X</em>，指 ISO 标准 <em>ISO/IEC 9899:2011</em></p></li></ol><h3 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h3><p>本文基于 C99（C11 引入了很多特性，值得玩味），使用最通用的写法，测试环境如下：</p><ul><li>编译器：LLVM version 10.0.1 (<code>clang-1001.0.46.4</code>)</li><li>平台：<code>x86_64-apple-darwin18.7.0</code></li></ul><h2 id="初探指针"><a class="markdownIt-Anchor" href="#初探指针"></a> 初探指针</h2><p>先来看一个简单的例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"foo:    %p\n"</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;foo:   %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p:      %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*p:     %p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;p:     %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行，如果不出意外的话，应该得到以下输出:</p><pre class="line-numbers language-none"><code class="language-none">foo:    0x5&amp;foo:   0x7ffee8ba3988p:      0x7ffee8ba3988*p:     0x5&amp;p:     0x7ffee8ba3980<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上编译得到两个 <code>warning</code>：应将打印 <code>*p</code> 的格式字符 <code>%d</code> 替换为 <code>%d</code>，<s>但是 who care?</s> 此处为了统一，将 <code>*p</code> 也以地址格式输出。</p><p>例程做了几件事：</p><ol><li>先定义一个变量 <code>foo</code>，初始化之后，很容易知道，值和地址分别为 <code>5</code> 和 <code>0x...988</code></li><li>再定义一个指针 <code>p</code>，将 <code>foo</code> 的地址赋给它，此时：<ul><li><code>p</code> 是 <code>foo</code> 的地址</li><li><code>*p</code> 是 <code>foo</code> 的值</li><li><code>&amp;p</code> 是 <code>p</code> 的地址</li></ul></li></ol><blockquote><p>为方便起见，在后续的例子中，省略了 <code>main()</code> 函数等代码，只在必要处给予说明。另由于现代操作系统地址随机化等内存保护措施，每次执行程序，变量的地址不一定相同，但绝对偏移是固定的，这点需要注意。</p></blockquote><h3 id="声明指针变量"><a class="markdownIt-Anchor" href="#声明指针变量"></a> 声明指针变量</h3><p>声明时，使用 <code>*</code> 代表要声明的变量是指针：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但我们有时候也看到：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上都是声明指针变量，<code>int</code> 是关键字，<code>int*</code> 显然不是（不会影响到对 <code>int</code> 的声明，但其实是声明 <code>int</code> 型的指针，后文会提到），在这种情况下，空格可有可无，实际上在 C 语言编译过程中，会忽略空格符、制表符和换行符。</p><p>所以只要逻辑没问题，下面代码可以如愿执行：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>    bar     <span class="token operator">=</span>     <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span>    <span class="token string">"66%d!\n"</span>   <span class="token comment">// 字符是一个整体，所以不能换行</span>      <span class="token punctuation">,</span>    bar<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种代码风格太抽象了，如果不想去世的话，不建议这么写。相信连自己也会看不下去的。</p><p>好，既然 <code>*</code> 放在哪都没有区别，那为什么会有 <code>int* p</code> 和 <code>int *p</code> 两种截然不同的形式存在呢？<s>当我 <code>int * p</code> 不存在。</s></p><p>通常，C 语言的声明格式类似 <code>类型 变量名</code>，如 <code>float pai</code> 声明类型为 <code>folat</code> 的变量 <code>pai</code>，而像 <code>double *pointer</code> 则是声明类型为 <code>double</code> 的指针变量 <strong><code>pointer</code></strong>，注意并不是 <code>*pointer</code>，因此，写成 <code>double*</code> 将之作为类型名似乎更合理，但请注意：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中只有 <code>foo</code> 是指针变量。可见，C 语言极其<s>混乱</s>灵活，很多现象<strong>不能一概而论</strong>。</p><h3 id="使用指针"><a class="markdownIt-Anchor" href="#使用指针"></a> 使用指针</h3><p>实际上第一个例程已经使用过了指针，这里再来总结一下。</p><ul><li>标识符（即指针变量）的 <strong>值是地址</strong></li><li><code>*</code> 解引用，根据地址得到所代表的的值（字符或数值）</li><li><code>&amp;</code> 获得变量的地址，可以用来将其他对象的 <strong>地址值</strong> 赋给指针变量</li></ul><p>指针变量存储的值是地址，所以以下代码，编译器不认为是定义指针，将产生 <code>incompatible integer to pointer conversion initializing 'double *' with an expression of type 'double'</code> 的 <code>warning</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但把值换成字符串就又可以了,甚至还可以通过指针来访问，所以说 C 语言很多现象不能一概而论。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token string">"hahaha"</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span> q <span class="token operator">=</span> <span class="token string">"that's ok"</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上字符串会作为只读变量单独存放，将以上代码反汇编后可以看到两处的字符串都作为常量存储在某一区域。</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjNgx.png" alt="#b# 反汇编后的符号表" /></p><h2 id="二探指针"><a class="markdownIt-Anchor" href="#二探指针"></a> 二探指针</h2><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><p>可能大多数 C 语言教材都会提到，一个数组 <code>arr[9]</code>，在表达式中如果只给出数组名 <code>arr</code>，其实就代表 <code>arr[0]</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr:        %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;arr[0]:    %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p:          %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr[0]:     %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*p:         %p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*arr:       %p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr[1]:     %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(p+1)):    %p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(arr+1):   %p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上例程运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">arr:        0x7ffee8461970&amp;arr[0]:    0x7ffee8461970p:          0x7ffee8461970arr[0]:     0x0*p:         0x0*arr:       0x0arr[1]:     0x1*(p+1):     0x1*(arr+1):   0x1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得到以下几个结论：</p><ol><li>作为表达式，数组名 <code>arr</code> 和指向该数组的指针变量 <code>p</code> 一样，其值都是地址</li><li>作为表达式，数组名 <code>arr</code> 的地址值与其第一个元素的地址值相同</li><li><code>arr[i]</code> 与 <code>*(arr + i)</code> 等效</li></ol><h3 id="下标运算符"><a class="markdownIt-Anchor" href="#下标运算符"></a> 下标运算符 <code>[]</code></h3><blockquote><p>声明中的 <code>[]</code> 和表达式中的 <code>[]</code> 意义不同，就跟声明中的 <code>*</code> 和表达式中的 <code>*</code> 意义不同一样。</p></blockquote><p>实际上，<code>arr[i]</code> 只是 <code>*(arr+i)</code> 的语法糖（syntax sugar）。</p><p>为什么说 <code>[]</code> 是语法糖呢？</p><p>引用轮子哥的 <a href="https://www.zhihu.com/question/24207261/answer/27023844">回答</a>：</p><ol><li>如果去掉了一个功能，语言有些事情就做不了了，这就不是语法糖，而是基础功能</li><li>如果去掉了一个功能，语言做那些事情只是麻烦了一点点，这就是语言功能重复，或者只是提供了缩写功能</li><li>如果去掉了一个功能，语言做那些事情还是能做，但是实在是麻烦太多了，这就是语法糖了</li></ol><p>以一个三维数组为例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> d_3_arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要访问 <code>13</code>，使用 <code>[]</code> 的形式为 <code>d_3_arr[2][1][0]</code>，使用指针的形式则为 <code>*(*(*(d_3_arr + 2) + 1) + 0)</code>。</p><p>似乎跟做梦一样。使用指针运算的形式不仅需要开发者耗费精力去计算下标，还要注意书写，写错一个 <code>()</code> 或者 <code>*</code> 就会出问题。这两种写法孰优孰劣，不难辨知。</p><p>众所周知，C 语言没有多维数组，有也是靠一维数组模拟出来的。使用 <code>for</code> 循环遍历该三维数组，可以得到各元素的地址，示意如下：</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjUv6.png" alt="#b# 多维数组内存分布图" /></p><p>可以清晰地看到，数组元素是线性分布的，数组初始化时指定了元素因此用 <code>0</code> 填补空缺，在我的环境下，<code>int</code> 型的数组每个元素占 <code>4</code> 字节。</p><p>数组的起始地址自然就是数组第一个元素的地址。当我们使用 <code>d_3_arr + 1</code> 得到的值就是红框部分数组的起始地址，以此类推。</p><blockquote><p>大家可以计算一下 <code>*(d_3_arr + 2) + 1</code> 及其对应的值是多少。</p></blockquote><p>现在来看一个骚操作：</p><ol><li>众所周知，<code>*(p+i)</code> 和 <code>*(i+p)</code> 显然是一样的</li><li>而 <code>p[i]</code> 又是 <code>*(p+i)</code> 的语法糖</li><li>所以，<code>p[i]</code> 又可以写成 <code>i[p]</code></li></ol><p>接上面的例子，以下代码可验证成功：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr[1]:     %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1[arr]:     %p\n"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">[</span>arr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="作为函数参数"><a class="markdownIt-Anchor" href="#作为函数参数"></a> 作为函数参数</h3><p>我们知道，函数内不能修改实参的值，但是通过指针可以，函数不能传数组，但是传指针可以。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在声明函数形参时，数组或被自动解读成指针，即使指定了元素个数也会被忽略，所以以上写法最终都会被理解成第一种形式。</p><p>还有一个著名的例子便是 <code>main()</code> 函数，声明成如下形式时（而不是 <code>int main(void);</code>），可获得命令行参数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>argc</code>：参数个数</li><li><code>argv</code>：包含参数字符串的二维数组</li></ul><p>再看一个较复杂的例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>a</code> 是个 <code>int</code> 型的二维数组，该数组的元素是一个 <code>int</code> 型的拥有 <code>5</code> 个元素的数组，而 <code>a</code> 这个数组的元素个数不需要明确，因为 <code>a</code> 最终会转成指针（如 <code>2</code> 所示）。</p><p>但有一点需要注意，声明的仅仅是指针，没有指定长度，所以在遍历数组时需要注意边界，或者在声明函数时就指定数组大小，就像 <code>main()</code> 函数中的 <code>argc</code> 一样。</p><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><p>C 语言中，定义 <strong>字符串</strong> 常量使用 <code>char</code> 数组</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"@_$tr1n9"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际上，上述是一种省略形式，会被编译器特别解释为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">'@'</span><span class="token punctuation">,</span> <span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token string">'$'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此后，我们可以通过数组的方法（下标运算符或指针运算）访问、修改该数组的内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此外，字符串也可以使用指针来定义，但无法修改内容，否则会报总线错误，因为使用这种方法定义，指针指向的是只读区域（见 <a href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88">使用指针</a> 一节）的字符串起始位置。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>string<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'d'</span><span class="token punctuation">;</span>    <span class="token comment">// bus error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过以下语句，可验证字符串常量是数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>正因为如此，我们可以使用以下方式获得字符：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token string">"0123456789"</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三探指针"><a class="markdownIt-Anchor" href="#三探指针"></a> 三探指针</h2><h3 id="指向函数的指针"><a class="markdownIt-Anchor" href="#指向函数的指针"></a> 指向函数的指针</h3><p>先来看看函数名是个什么东西。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hh\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func:   %p\n"</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;func:  %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">func:0x10b56cf20&amp;func:0x10b56cf20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>正如数组名在表达式中可以被解读成指针一样，函数名也意味着指向函数的指针，其标识符就是初始地址。实际上各种类型都是如此————标识符是起始地址，只不过数组、结构体等有大小，而函数没有大小。</p><p>如果想在函数里调用另一个函数，这很简单，直接通过标识符调用即可。<strong>接上例</strong>， <code>main()</code> 函数中使用如下语句都可成功调用 <code>func()</code> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只要能获得 <code>func</code> 这个标识符或者说对应的地址即可。</p><p>但如果标识符不确定呢？即函数名未知，该如何调用？</p><p>参照函数传参，如果将被调函数的起始地址传入主调函数，即可调用之。函数在表达式中，应理解成指向函数的指针，比如在信号处理程序中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">signal</span><span class="token punctuation">(</span>SIGSEGV<span class="token punctuation">,</span> segv_handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGSEGV<span class="token punctuation">,</span> <span class="token operator">&amp;</span>segv_handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们已经知道，以上两种方式都是传递函数的起始地址，然后按照之前提到的调用方式，所以都能成功。</p><p>似乎很合理，但是主调函数的声明尤其是参数表该怎么写？这就涉及到函数指针了。</p><p>来看这个例程：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>callee<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a: hhh\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b: hhhh\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>int (*callee)()</code> 是一个函数指针，其标识符（即形参）为 <code>callee</code>，就跟 <code>int func(int *a)</code> 这样的声明没什么两样，只不过声明函数需要带括号 <code>()</code>。</p><p>同样，类比普通变量的指针，函数指针也可以获得另一个函数的地址，从而代为调用。看以下例程的  <code>*(func)()</code> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>callee<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a: hhh\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b: hhhh\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    func <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// (*func)(b); 与之相同</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，函数指针 <code>func</code> 可以绑定任何与之类型相同的函数，并且调用了。</p><p>上面这句话提到了一个词————<em>类型</em>，现在来看这个迟到的概念。</p><h3 id="派生类型"><a class="markdownIt-Anchor" href="#派生类型"></a> 派生类型</h3><p>C 语言类型有基本类型和派生类型之分。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参照《征服 C 指针》中“类型链的表示”，以上类型可图示如下：</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjYCR.png" alt="#b# 类型链表示" /></p><p>链最后面的（即图中第一个）元素是基本类型，后面的则都是派生类型。</p><p>好，现在可以群魔乱舞了。如何解读以下语句（<a href="https://zhuanlan.zhihu.com/p/85191629" title="知乎专栏">来自知乎专栏</a>）？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要明确，不管类型链画成什么花，类型都是由基本类型和指针、数组、函数、结构体等派生类型组成的，而派生类型可以不断（递归或者重复）组合，就可以生成无限种派生类型。而每种类型都有类别，同样借用《征服 C 指针》中的概念，称这种类别为 <em>类型分类</em>。</p><p>对于“类型链”表示里的两个例子，我们不加解释（解释方法见下文）地给出解读：</p><ol><li><code>p</code> 是一个指向 <code>double</code> 的 <strong>指针</strong></li><li><code>func</code> 是一个拥有 <code>9</code> 个元素（并且元素为指向（参数为 <code>float</code>、返回值为 <code>int</code> 的函数）的指针）的 <strong>数组</strong></li></ol><p>可以看到，这样的解读类似下定义，其宾语就是 <em>类型分类</em>，同时也是链的第一个（即图中最后一个）元素。就像二维数组 <code>arr[m][n]</code> 一样，把数组抽象成子元素，层层嵌套。</p><h3 id="解读-c-声明"><a class="markdownIt-Anchor" href="#解读-c-声明"></a> 解读 C 声明</h3><p>所以，怎么来明确这个 <em>类型分类</em> 呢？或者说如何得到类型链的表示呢？</p><p>借用《征服 C 指针》的方法：</p><blockquote><p>在这里，向读者介绍阅读 C 语言声明的方法：机械地向前读。</p><p>为了把问题变得简单，我们在这里不考虑 <code>const</code> 和 <code>volatile</code>。接下来遵循以下步骤来解释 C 的声明。</p><ol><li>首先着眼于标识符（变量名或者函数名）。</li><li>从距离标识符最近的地方开始，依照优先顺序解释派生类型（指针、数组和函数）。优先顺序如下：<ol><li>用于整理声明内容的括弧</li><li>用于表示数组的 <code>[]</code>，用于表示函数的 <code>()</code></li><li>用于表示指针的 <code>*</code></li></ol></li><li>解释完成派生类型，使用 “of”、“to”、“returning” 将它们连接起来。</li><li>最后追加数据类型修饰符（在左边，<code>int</code>、<code>double</code> 等）。</li><li>英语不好的人，可以倒序用日语（或者中文）解释。</li></ol></blockquote><p>个人认为最主要的就是第 <code>1</code> 步和第 <code>2</code> 步，可以明确 <em>类型分类</em>，至于其它，都是定语而已，可以慢慢往上添。</p><p>看下面例子，区别就在于有无括号 <code>()</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func_p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">func_p</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>首先着眼于标识符 <code>func_p</code>；<br /><code>func_p is</code></li><li>对于 <code>1</code>，周围存在括号，所以 <code>*</code> 优先，<code>func_p</code> 是一个 <strong>指针</strong>；<br /><code>func_p is pointer to</code></li><li>解释完 <code>(*func_p)</code>，后面是表示函数的括号 <code>()</code> 以及参数 <code>double</code>；<br /><code>func_p is pointer to function(double) returning</code></li><li>数据类型是 <code>int</code>，完工。<br /><code>func_p is pointer to function(double) returning int</code></li></ol><p>而对于 <code>2</code>，不存在括号，所以按照优先级先解释表示函数的 <code>()</code>，所以 <code>func_p</code> 是一个函数，且参数为 <code>double</code>，返回值为 <code>int *</code>，即返回 <code>int</code> 型的指针变量。</p><p>所以按照上述方法，以下式子即可迎刃而解：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个，很简单，写成以下形式秒秒钟明白：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> <span class="token operator">*</span> a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>a</code> 是元素类型为 <code>float</code> 型指针的数组而已。</p><p>第二个，<code>a</code> 是个指针，指向一个数组（拥有 <code>9</code> 个 <code>float</code> 型的元素）。</p><p>如果不出意外的话，群魔乱舞的例子解释完了（n 级指针无需多言，当然理解和使用是两种概念）。</p><h3 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h3><p>我们来看前面出现过的 <code>signal()</code> 函数的原型声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>首先看标识符，语句中有两个标识符：<code>signal</code>、<code>sig</code> 和 <code>func</code>，明显可以知道后两者是作为函数参数，所以主体是 <code>signal</code></li><li>按照优先顺序，离标识符最近的是表示函数的括号 <code>()</code>，所以整个语句声明的是一个函数<ul><li>参数：除 <code>int</code> 型的 <code>sig</code>之外，还有  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>分离之后就不难理解，<code>func</code> 是一个指针，指向一个函数（参数为 <code>int</code>、返回 <code>void</code>）</li><li>返回值：一个指针  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li>现在得到了一个指针，用标识符 <code>SIG</code> 替代，则整条语句转换为： <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>SIG<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>该指针指向一个函数（参数为 <code>int</code>、返回 <code>void</code>）</li></ol><p>类型链表示如下：</p><p><img src="https://s2.ax1x.com/2020/01/19/1Cjt81.png" alt="#b# 类型链表示" /></p><p><code>signal()</code> 函数是用于注册信号处理的函数，按照如下方式调用后，返回之前注册的处理当前信号中断的函数（这个函数显然得用指针来表示）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">signal</span><span class="token punctuation">(</span>SIGSEGV<span class="token punctuation">,</span> segv_handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>SIGSEGV</code>：信号类型</li><li><code>segv_handle</code>：信号处理程序，就是传入的函数（的地址）</li></ul><p><code>signal()</code> 函数及 <code>segv_handle()</code> 都有相同的结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，借助 <code>typedef</code>，可以使声明更加清晰：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sig_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">sig_t</span><span class="token punctuation">;</span><span class="token class-name">sig_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token class-name">sig_t</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="#%E8%A7%A3%E8%AF%BB-c-%E5%A3%B0%E6%98%8E">解读 C 声明</a> 的引述中有这样一句话：</p><blockquote><p>为了把问题变得简单，我们在这里不考虑 <code>const</code> 和 <code>volatile</code>。</p></blockquote><p>关于 <code>volatile</code> 修饰符后续再讨论。<s>（因为我还没怎么接触到。）</s> 现在来看 <code>const</code> 修饰符。</p><h4 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> 修饰符</h4><p>C 语言修饰符（specifier）包括但不限以下几个：</p><ul><li><code>inline</code></li><li><code>restrict</code></li><li>类型修饰符<ul><li><code>const</code></li><li><code>volatile</code></li></ul></li><li>存储类型修饰符<ul><li><code>auto</code></li><li><code>static</code></li><li><code>register</code></li><li><code>extern</code></li><li><code>typedef</code></li></ul></li></ul><p>关于这几个修饰符后续再讨论，在这里是为了明确类型修饰符和存储类型修饰符可以一起使用。</p><h4 id="const"><a class="markdownIt-Anchor" href="#const"></a> <em>const</em></h4><p><em>const</em> 可以将变量修饰为 <strong>只读</strong>，因此，常量就可以使用 <code>const</code> 来声明，<code>const</code> 也经常见于函数原型的参数列表。</p><p><code>strcpy()</code> 函数就是一个范例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，成为只读的不是 <code>src</code>，而是 <code>src</code> 所指向的对象</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">f_strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    src <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token comment">// success</span>    <span class="token operator">*</span>src <span class="token operator">=</span> <span class="token string">"hhhhh"</span><span class="token punctuation">;</span> <span class="token comment">// failed</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>const</code> 修饰的是 <code>*src</code> 这一个整体，而不是 <code>src</code> 这个指针变量，即变量可以绑定其他地址。</p><p>如果要变量只读和都只读，可分别声明为如下形式（两处 <code>const</code> 都修饰了 <code>src</code>）：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">f_strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> src<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    src <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token comment">// failed</span>    <span class="token operator">*</span>src <span class="token operator">=</span> <span class="token string">"hhhhh"</span><span class="token punctuation">;</span> <span class="token comment">// success</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">f_strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> src<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    src <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token comment">// falied</span>    <span class="token operator">*</span>src <span class="token operator">=</span> <span class="token string">"hhhhh"</span><span class="token punctuation">;</span> <span class="token comment">// failed</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>const</code> 可以和 <code>char</code> 一起使用，排列组合一下，得到如下五种形式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">char</span> p<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定睛一看，<code>const * char p</code> 是个什么东西？去掉修饰符为 <code>* char p;</code>，根本不符合语法规范。其次，<code>const char * p</code> 和 <code>char const * p</code> 效果一样，所以只有以下三种形式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="再谈函数调用"><a class="markdownIt-Anchor" href="#再谈函数调用"></a> 再谈函数调用</h3><p><a href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88">指向函数的指针</a> 一节提到，使用以下方式都可以成功调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，函数调用运算符 <code>()</code> 的对象是函数指针，而函数在表达式中会自动转换成指向函数的指针。如果对指向函数的指针解引用 <code>*</code>，会暂时成为函数，但因为在表达式中，又会变为指向函数的指针，因此 <code>*</code> 运算符发挥不了作用，以下函数可正常调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>printf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="void-0"><a class="markdownIt-Anchor" href="#void-0"></a> <code>(*(void (*)())0)()</code></h3><p>现在来解释封面的函数。某些运行于微处理器上的程序在启动计算机时，硬件将调用首地址为 <code>0</code> 的程序。为了模拟开机启动的情形，需要设计一个 C 语句，显式调用该程序，所以就有了这条语句。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如有一个函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可使用如下语句调用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>func</code> 是指向函数的指针变量，即函数入口地址，那么这里入口地址是 <code>0</code>，但 <code>0</code> 不能作为函数指针，需要进行类型转换。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上式是一个指向返回值和参数都为空的函数的指针，可用来进行类型转换，转换之后如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进行函数调用，得到最终的语句。</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>读到这里，或许可以发现，以上内容部分概念有些许重复，因为 C 语言的指针和数组是类似的，却又不完全相同，尽管我极力想把结构理清楚，但概念就是这么零碎的存在，所以按照话题来论述也无妨，融会贯通才是最终目标。<s>实际上，《征服 C 指针》中也是分离各个话题的，造成很多概念提了又提的现象。</s> 文章题目仿自鲁迅先生的《关于章太炎先生二三事》，当然文章内容与原著无关。本文以 C 指针为主要对象，但记录的不只是指针，<s>（擒贼先擒王）</s>，而是围绕 C 语言一系列的坑与概念。</p><p>因为阅历和资历问题，我没法像《征服 C 指针》和《C 陷阱与缺陷》两位作者一样，援引经典文献，从历史根源出发讨论问题，因此我的论述从实验结果出发，我深知从现象看问题不可能全面，纰漏之处难免，还请各位不吝赐教。</p><p>其实后记的内容本该放在前言，但头重脚轻似乎不妥，所以放在这个不重要 <s>（看都不看）</s> 的角落。学习 C 语言是一辈子的事情，因此本文将持续更新，有必要时将会分解成系列文章。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li>《征服 C 指针》</li><li>《C 陷阱与缺陷》</li><li><a href="https://zhuanlan.zhihu.com/p/85191629" title="知乎专栏">神一般的C语言指针， 你看懂了多少？</a></li><li><a href="https://www.zhihu.com/question/66890284/answer/247582078" title="知乎回答">C语言中-j—i怎样结合？ - vczh的回答 - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gmpy2 编译安装的坑</title>
      <link href="2019/11/gmpy2-bian-yi-an-zhuang-de-keng/"/>
      <url>2019/11/gmpy2-bian-yi-an-zhuang-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p>GMP，GNU Multiple Precision Arithmetic Library，GNU 高精度算术运算库</p></blockquote><p>gmpy2 是 <a href="https://www.python.org/">Python</a> 的一个扩展库，常用在 CTF 的 Crypto 题中分解大素数。</p><ul><li><a href="https://github.com/aleaxit/gmpy">Github</a></li><li><a href="https://pypi.org/project/gmpy2/">PyPi</a></li><li><a href="https://gmpy2.readthedocs.io/en/latest/">文档</a></li></ul><h2 id="tddr"><a class="markdownIt-Anchor" href="#tddr"></a> TD;DR</h2><p>本文记录 Kali 下编译安装 gmpy2 的过程，过程挺艰难，需要在网上爬很多帖，但后来发现，可以直接使用 apt 命令来安装，所以踩坑记录变成了部署记录。使用以下两条命令即可完成安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> m4 libgmp-dev libmpfc-dev libmpc-dev$ pip3 <span class="token function">install</span> gmp2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>APT 具有超级牛力。</p></blockquote><h2 id="编译环境"><a class="markdownIt-Anchor" href="#编译环境"></a> 编译环境</h2><p>好，所以现在开始编译安装。首先确保安装了 gcc 和 make。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> gcc <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Kali：5.2.0-kali2-amd64u</li><li>GCC：8.3.0</li><li>Make：4.2.1</li></ul><h2 id="安装依赖库"><a class="markdownIt-Anchor" href="#安装依赖库"></a> 安装依赖库</h2><p>gmpy2 依赖 GMP、MPFR、MPC 三个库，需要提前安装。</p><p>为便于指定编译路径，先使用变量指定文件夹。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p <span class="token environment constant">$HOME</span>/gmpy2$ <span class="token assign-left variable">GMPY</span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/gmpy2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>预先下载好所有依赖库的文件包，并解压，依次进入文件夹进行编译。</p><h3 id="m4"><a class="markdownIt-Anchor" href="#m4"></a> m4</h3><p><a href="http://ftp.gnu.org/gnu/m4/" title="下载列表">m4</a> 是 <em>POSIX</em> 标准中的一部分，所有版本的 UNIX 下都可用。虽然这种语言可以单独使用，但大多数人需要 m4 仅仅是因为 GNU autoconf 中的 <em>configure</em> 脚本依赖它。</p><p>m4 模块最新版本是 <code>1.4.18</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">v</span><span class="token operator">=</span><span class="token number">1.4</span>.18$ <span class="token builtin class-name">cd</span> m4-<span class="token variable">$&#123;v&#125;</span>$ ./configure -prefix<span class="token operator">=</span>/usr/local$ <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> check <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gmp"><a class="markdownIt-Anchor" href="#gmp"></a> GMP</h3><blockquote><p><a href="https://gmplib.org" title="官网">GMP</a>，GNU Multiple Precision Arithmetic Library，GNU 高精度算术运算库</p></blockquote><p>GMP 提供了大量操作高精度大整数、浮点数的算术库，可直接使用，详细操作见 <a href="https://gmplib.org/gmp-man-6.1.0.pdf" title="文档">官方文档</a>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">v</span><span class="token operator">=</span><span class="token number">6.1</span>.2$ <span class="token builtin class-name">cd</span> gmp-<span class="token variable">$&#123;v&#125;</span>$ ./configure --prefix<span class="token operator">=</span><span class="token variable">$GMPY</span> --enable-static --disable-shared --with-pic$ <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> check <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mpfr"><a class="markdownIt-Anchor" href="#mpfr"></a> MPFR</h3><blockquote><p>The MPFR library is a C library for multiple-precision floating-point computations with correct rounding. MPFR has continuously been supported by the INRIA and the current main authors come from the Caramba and AriC project-teams at Loria (Nancy, France) and LIP (Lyon, France) respectively; see more on the credit page. MPFR is based on theGMP multiple-precision library.</p></blockquote><p><a href="https://www.mpfr.org" title="官网">MPFR</a> 是一个基于 GMP 库的高精度浮点计算库，因此需要先按照 GMP。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">v</span><span class="token operator">=</span><span class="token number">4.0</span>.2$ <span class="token builtin class-name">cd</span> mpfr-<span class="token variable">$&#123;v&#125;</span>$ ./configure --prefix<span class="token operator">=</span><span class="token variable">$GMPY</span> --enable-static --disable-shared --with-pic --with-gmp<span class="token operator">=</span><span class="token variable">$GMPY</span>$ <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> check <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mpc"><a class="markdownIt-Anchor" href="#mpc"></a> MPC</h3><p><a href="http://www.multiprecision.org/mpc/">MPC</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">v</span><span class="token operator">=</span><span class="token number">1.1</span>.0$ <span class="token builtin class-name">cd</span> mpc-<span class="token variable">$&#123;v&#125;</span>$ ./configure --prefix<span class="token operator">=</span><span class="token variable">$GMPY</span> --enable-static --disable-shared --with-pic --with-gmp<span class="token operator">=</span><span class="token variable">$GMPY</span> --with-mpfr<span class="token operator">=</span><span class="token variable">$GMPY</span>$ <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> check <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装-gmpy2"><a class="markdownIt-Anchor" href="#安装-gmpy2"></a> 安装 gmpy2</h2><p>使用安装脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python setup.py build --prefix<span class="token operator">=</span><span class="token variable">$GMPY</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接使用 pip：</p><pre class="line-numbers language-none"><code class="language-none">$ pip3 install gmpy2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不出意外的话，到此就安装成功了。<s>但出了意外就还得爬帖了，（逃</s></p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://www.cnblogs.com/pcat/p/5746821.html">gmpy2安装使用方法</a></li><li><a href="https://www.jianshu.com/p/0ab4b0d8facb">python2/3 gmpy2库在linux下安装</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 CTFd 搭建靶场</title>
      <link href="2019/10/shi-yong-ctfd-da-jian-ba-chang/"/>
      <url>2019/10/shi-yong-ctfd-da-jian-ba-chang/</url>
      
        <content type="html"><![CDATA[<p>众所周知，渗透测试练习有许多平台可供使用，比如 <a href="https://sourceforge.net/projects/metasploitable/">Metasploitable</a>、<a href="http://dvwa.co.uk/" title="Homepage">DVWA</a> 等环境，而搭建 CTF 平台也有许多项目可供参考，如 <a href="https://ctfd.io/" title="Homepage">CTFd</a>、<a href="https://github.com/facebook/fbctf" title="Github">FBCTF</a>，一些比赛以及各个大学的练习站点就使用了这些项目。</p><p>CTFd 可使用多种方式 <a href="https://github.com/CTFd/CTFd/wiki/Advanced-Deployment" title="Github">部署</a>，为了以更加轻便的方式运行，此处使用 <a href="https://www.docker.com/" title="Homepage">Docker</a>。</p><h2 id="环境部署"><a class="markdownIt-Anchor" href="#环境部署"></a> 环境部署</h2><h3 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h3><ol><li>安装 Docker 的依赖</li></ol>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> yum-utils device-mapper-persistent-data lvm2 bind-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>添加 Docker 的源，再 <a href="https://docs.docker.com/install/linux/docker-ce/centos/" title="Docs">安装 Docker</a> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">  $ yum-config-manager <span class="token punctuation">\</span>--add-repo <span class="token punctuation">\</span>https://download.docker.com/linux/centos/docker-ce.repo  $ yum <span class="token function">install</span> docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="docker-compose"><a class="markdownIt-Anchor" href="#docker-compose"></a> Docker Compose</h3><p><a href="https://github.com/docker/compose" title="Github">Docker Compose</a> 使用 Python 开发，因此需先安装好 Python 的 pip</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> epel-release python-pip$ pip <span class="token function">install</span> docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="启动-ctfd"><a class="markdownIt-Anchor" href="#启动-ctfd"></a> 启动 CTFd</h2><h3 id="ctfd"><a class="markdownIt-Anchor" href="#ctfd"></a> CTFd</h3><ol><li>下载 <a href="https://github.com/CTFd/CTFd" title="Github">CTFd</a> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/CTFd/CTFd.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>进入 <code>CTFd</code>，会发现项目文件夹中还有一个 <code>CTFd</code> 文件夹 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> CTFd$ docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><code>docker-compose</code> 使用了 Docker API，等同于 <code>docker</code>，<code>up</code> 选项构建、运行容器，<code>-d</code> 参数表示在后台运行。</li></ol><p>首次构建将拉取几个镜像（mariadb、python、redis 等），速度较慢，等到脚本跑完，就可以在本地通过 <code>http://127.0.0.1:8000</code> 访问。初次运行需注册 Admin 用户，填写相关信息。</p><h3 id="汉化"><a class="markdownIt-Anchor" href="#汉化"></a> 汉化</h3><p>其实没必要汉化，不过为了后期可定制化，<a href="https://github.com/Gu-f/CTFd_chinese_CN" title="CTFd_chinese_CN">此处</a> 为汉化项目的地址，不过该项目只汉化了选手的界面，管理员相关页面仍为英文。</p><ol><li>下载汉化包 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/Gu-f/CTFd_chinese_CN.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>替换或者增加 theme<ul><li>将 <code>core_chinese</code> 文件夹直接放入 <code>CTFd/CTFd/themes</code> 目录</li><li>将 <code>themes</code> 直接替换 <code>CTFd/CTFd</code> 目录下的 <code>themes</code> 即可</li></ul></li></ol><h2 id="动态独立靶机"><a class="markdownIt-Anchor" href="#动态独立靶机"></a> 动态独立靶机</h2><p>现在很多比赛都使用了动态独立靶机（dynamic standalone instance），每道题目环境分离，且能为每个队伍生成独一无二的 flag，动态创建也能减少资源开销。</p><p>此处使用 <a href="https://www.zhaoj.in/">赵师傅</a> 的 [CTFd-whale]</p><p>根据 README，需要下载 <a href="https://github.com/fatedier/frp/">frps</a>，以实现穿透</p><p>在 <code>docker-compose.yml</code> 的 <code>volume:</code> 添加：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">service:  volumes:    - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li><a href="https://blog.csdn.net/fjh1997/article/details/100850756">手把手教你如何建立一个支持ctf动态独立靶机的靶场（ctfd+ctfd-whale）</a></li><li><a href="http://www.gtfly.top/2019/09/27/CTFd%E5%8A%A8%E6%80%81docker%E9%95%9C%E5%83%8F%E7%BC%96%E5%86%99.html#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81flag">CTFd动态flag镜像编写</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑小记——薛定谔的 Console.log()</title>
      <link href="2019/09/cai-keng-xiao-ji-xie-ding-e-de-console-log/"/>
      <url>2019/09/cai-keng-xiao-ji-xie-ding-e-de-console-log/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写作本文时我已经理清了思路，但在当时走投无路、无计可施的情况下难免会忽略一些细节。复现问题时使用的是简单的例子，表现意思即可，故在此无需探讨例子的意义</p></blockquote><p>今天写代码时，调试一个数组对象，想把内容都打印出来，就直接 <code>console.log()</code>，把三角形展开，如下：</p><p><img src="https://s2.ax1x.com/2019/09/01/nptMD0.jpg" alt="" /></p><p>可以看到，<code>0:</code> 和 <code>1:</code> 对应的值都不是数组 <code>[]</code> 中的值，<code>0</code> 和 <code>1</code> 是数组的索引值，从 <code>0</code> 开始，没问题，但是为何对应的值不匹配呢？</p><p>在调试时，类似 <code>(2) [22, 2]</code> 行输出的是二维数组，因此输出不能一目了然，我认为没有预期输出是代码问题，因此审视了一遍代码，严格理了一遍逻辑发现并没有错误 <s>，除了一些小 Bug</s></p><p>走投无路时，发现有如下 <code>!</code> 的标记：</p><p><img src="https://s2.ax1x.com/2019/09/01/npJLWj.jpg" alt="" /></p><p>鼠标悬停，弹出如下提示：</p><p><img src="https://s2.ax1x.com/2019/09/01/npJqYQ.png" alt="" /></p><p>意识到可能这里存在“未解之谜”，<a href="https://www.bing.com">Bing</a> 之后，发现果然存在玄机：<a href="https://segmentfault.com/a/1190000018831992">记一次&quot;Value below was evaluated just now&quot;</a></p><p>我还是太年轻，<code>0</code>、<code>1</code>、<code>2</code>……输出的不是数组的值，而是最终改变的值，因此，在运行时展开，此时的值是展开那个时间点的值，就像封面图一样：</p><p><img src="https://s2.ax1x.com/2019/09/01/npJXSs.png" alt="" /></p><blockquote><p>当你在控制台展开打印出来的数组（或者对象）的时候，如果此时数组（或者对象）的数据已经发生了改变，那么将显示改变之后的数据。如果此时数组（或者对象）的数据没有发生改变，那么就一直显示此时的数据</p></blockquote><p>这个值不是固定的，而是视展开时的情况而定，就像电子双缝干涉实验所表现出来的，有无观察者会对结果产生影响</p><p><img src="http://tomcat.apache.org/res/images/tomcat.png" alt="Tomcat" /></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑小记——Webpack resolve</title>
      <link href="2019/08/cai-keng-xiao-ji-webpack-resolve/"/>
      <url>2019/08/cai-keng-xiao-ji-webpack-resolve/</url>
      
        <content type="html"><![CDATA[<p>前段时间，学习了 <a href="https://webpack.js.org/">Webpack</a>、<a href="https://ejs.co/">EJS</a>、<a href="https://babeljs.io/">Babel</a> 等工具，在学习 <a href="https://reactjs.org/">React</a> 及其全家桶时，开始着手开发一些项目，以此巩固和提高。遂在之前一个已有项目的基础上，建立项目文件夹，项目结构如下：</p><pre class="line-numbers language-none"><code class="language-none">repo├── todo-list│  ├── webpack.config.js│  ├── screenshots│  ├── server│  ├── dist│  └── src│     ├── components│     ├── index.html│     ├── index.jsx│     ├── layout│     └── style├── package.json├── node_modules└── README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>repo</code> 为 Git 文件夹，除了 <code>todo-list</code> 这个文件夹以外还有其他项目文件夹，各个项目共用一个 <code>node_modules</code><s>，以节省空间</s></p><p>Webpack 入口（Entry）在 <code>index.jsx</code>，一般情况下，引用 <code>components</code> 文件夹下的 <code>container</code> 组件，代码应为：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> Container <span class="token keyword">from</span> <span class="token string">'./layout/container'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>webpack.config.js</code> 配置如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token constant">ENTRY</span> <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'src'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token constant">OUTPUT</span> <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token constant">ENTRY</span><span class="token punctuation">,</span> <span class="token string">'index.jsx'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        path<span class="token operator">:</span> <span class="token constant">OUTPUT</span><span class="token punctuation">,</span>        filename<span class="token operator">:</span> <span class="token string">'index.bundle.js'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建运行，结果却是：</p><p><img src="https://s2.ax1x.com/2019/08/19/m3hly6.png" alt="" /></p><p>提示无法解析 <code>./layout/container</code>，猜测可能是相对于 Webpack 配置文件的路径，考虑到项目可能会扩大，因此添加 alias，并且修改 import 语句，</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token constant">ENTRY</span> <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'src'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token constant">OUTPUT</span> <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token constant">ENTRY</span><span class="token punctuation">,</span> <span class="token string">'index.jsx'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        path<span class="token operator">:</span> <span class="token constant">OUTPUT</span><span class="token punctuation">,</span>        filename<span class="token operator">:</span> <span class="token string">'index.bundle.js'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    resolve<span class="token operator">:</span> <span class="token punctuation">&#123;</span>alias<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token string">"src"</span><span class="token operator">:</span> <span class="token constant">ENTRY</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><s>此处的 <code>&quot;src&quot;: ENTRY</code> 似乎多此一举，但当时配置文件在 <code>repo</code> 文件夹，因此还有一个 <code>todo-list</code> 文件夹，路径更长</s></p><p>依旧报错……去掉 alias，还是报错，<em>How old are you？</em> 最后把组件和入口文件全部放在一起，还是报错……</p><p>意识到这应该不是路径的问题，可能是 Webpack 配置不对，再去翻文档，<a href="https://webpack.docschina.org/configuration/resolve/#resolve-alias"><code>resolve.alias</code></a>，按照文档的意思，alias 配置没有问题，再去 <a href="https://www.zhihu.com/">知乎</a>、<a href="https://www.bing.com/">Bing</a> 搜索 alias 的用法，虽然大家写法不一，但总体和我是差不多的，但是 Webpack 似乎没有用上 alias 这一功能~~，虽然也看不出来，都是无法解析~~</p><p>最后搜索 <code>Module not found</code>，终于找到了些眉目：<a href="https://www.jianshu.com/p/f5d1d73fe414">Module not found: Error: Can’t resolve ‘react’ in · 简书</a>，在这里，居然发现有 <code>resolve.modules</code> 这一项，山穷水复的情况下，拿来直接用，居然成功打包！！！</p><hr /><p>文档如下：</p><blockquote><p>resolve.modules<br /><code>[string]: ['node_modules']</code><br />告诉 webpack 解析模块时应该搜索的目录。<br />……<br />如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索</p></blockquote><p>该选项给出解析时的路径，默认是 <code>node_modules</code>，查找是会先从最近的 <code>node_modules</code> 目录里找，找不到则往上层找~~，因此，我之前共用一个包文件夹的设想是成功的~~</p><p><strong>可添加自定义的模块</strong>，路径应写在 <code>'node_modules'</code> 之前</p><hr /><p>因此，在这里，应配置为：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token constant">ENTRY</span> <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'src'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token constant">OUTPUT</span> <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token constant">ENTRY</span><span class="token punctuation">,</span> <span class="token string">'index.jsx'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        path<span class="token operator">:</span> <span class="token constant">OUTPUT</span><span class="token punctuation">,</span>        filename<span class="token operator">:</span> <span class="token string">'index.bundle.js'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    resolve<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        extensions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'.js'</span><span class="token punctuation">,</span> <span class="token string">'.jsx'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        modules<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">ENTRY</span><span class="token punctuation">,</span> <span class="token string">'node_modules'</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至于 alias 和 <code>index.js</code> 中的 import 语句，爱咋样咋样，保持原样即可</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IRC 浅尝</title>
      <link href="2019/05/irc-qian-chang/"/>
      <url>2019/05/irc-qian-chang/</url>
      
        <content type="html"><![CDATA[<p>不久前接触到 IRC，感觉很有意思，遂了解了一下，记录下来。最近 <a href="https://d3ctf.io/">D^3CTF</a> 官方提供了一个 IRC 频道，想进去水一水，结果发现 IRC 不怎么会用了，在此检讨一下，重新学习。</p><p><img src="https://s1.ax1x.com/2019/11/19/MgOSB9.png" alt="#b# D^3CTF" title="#d^3ctf" /></p><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><blockquote><p>因特网中继聊天（Internet Relay Chat，IRC）是一种历史悠久、应用广泛、成熟稳定的 <strong>网络即时通讯协议</strong>，被广泛地应用于在线通讯和网络聊天中。IRC 最早由芬兰人 <em>雅尔口·欧伊卡林恁</em>（Jarkko Oikarinen）于 1988 年 8 月创造以取代一个叫做 MUT 的程序，随后便一直在互联网中扮演重要角色。凡是支持互联网的操作系统，几乎都可以使用 IRC。虽然在 2003 年以后，许多功能更加丰富的聊天程序和服务取代了只能进行纯文字交流的 IRC，许多曾经的大型 IRC 服务器日渐式微，失去了 60% 的使用者。但对于许多应用来说，依然是一种方便可靠的通讯方式。（来自 <a href="https://zh.wikibooks.org/wiki/IRC">Wikipedia</a>）</p></blockquote><p>我们有时会在电影里看到，黑客使用终端进行聊天，这似乎非常奇妙，<s>黑客可以用终端做任何事情</s> 就像下面这样。</p><p><img src="https://s1.ax1x.com/2019/11/20/MRdJjH.png" alt="#b# 《Mr.Reboot》截图" /></p><p>这是一种通讯方式，称为 IRC。</p><p>IRC 的实现方式，简言之，就是 IRC 用户使用 <strong>客户端</strong> 软件连接到 <strong>IRC 服务器</strong>，通过服务器 <strong>中继</strong> 与其他连接到这一服务器上的用户交流。</p><p>众所周知，A 与 B 可以直接进行通信，但 A、B 和 C 的通信则需要借助第三方 S 进行转发，如果参与到通信的人越来越多，则 S 的负担会越来越重。</p><p>因此如果有多个服务器，形成一张网络，服务器之间转发消息，用户只需要登录其中一个服务器，发送的消息就可以推送到各个用户节点。这一切通过互联网进行，因此称为 <em>互联网中继聊天</em>。</p><h3 id="聊天网络"><a class="markdownIt-Anchor" href="#聊天网络"></a> 聊天网络</h3><p>从一个 IRC 服务器可以连接其他服务器，由此构成一个网络。依据 IRC 协议组成的聊天网络，常见的有：</p><ul><li><a href="https://freenode.net" title="主页"><em>freenode</em></a>：<a href="http://irc.freenode.net">irc.freenode.net</a></li><li><em>EFnet</em>：<a href="http://www.efnet.org">www.efnet.org</a></li><li><em>EFPer</em></li><li><em>DALnet</em></li></ul><p>大多数的 IRC 服务器不需要客户注册登录，但是在连接前必须设定好昵称（nickname）。</p><h3 id="频道"><a class="markdownIt-Anchor" href="#频道"></a> 频道</h3><p>频道的本质是广播室，相当于群组<s>聊天室</s>。</p><ul><li>单个 <code>#</code> 开头的频道表明这是一个和自由和开源软件项目有关的正式交流频道</li><li>两个 <code>#</code> 号开头的频道表明这是一个非官方、非正式，或和某个项目无关的自由讨论频道</li></ul><p>以下为几个较为活跃的频道 <s>2019 年未必日常活跃</s>：</p><ul><li><code>#wikipedia-zh</code>：中文维基百科交流使用的官方正式频道</li><li><code>#ubuntu-cn</code>：Ubuntu 中文社区频道</li><li><code>#linuxba</code>：Linux 贴吧频道</li><li><code>#haskell</code>：Haskell 语言频道</li><li><code>#c_lang_cn</code>：C 语言 IRC 频道</li><li><code>#vim</code>：Vim 社区频道</li><li><code>#openstack-chinese</code></li><li><code>#git</code></li><li><code>##javascript</code></li><li><code>#macosx</code></li><li><code>#ustc_lug</code></li><li><code>#kali</code></li><li><code>#debiancn</code></li><li><code>#osdev</code></li></ul><p>以下为几个官方的频道列表：</p><ul><li>KDE <a href="https://userbase.kde.org/IRC_Channels/zh-cn">频道列表</a></li><li>Arch <a href="https://wiki.archlinux.org/index.php/Arch_IRC_channels">频道列表</a></li><li>CentOS <a href="https://wiki.centos.org/zh/irc">频道列表</a></li></ul><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><p>传统的 IRC 是基于文本的，因此，<strong>图片</strong> 和表情则无法发送，若实在有必要，可使用图床等在线工具，这样一来只需发送图片链接即可。这里提供了几个网站可以张贴图片：</p><ul><li><a href="http://img.vim-cn.com/">http://img.vim-cn.com/</a></li><li><a href="http://paste.edisonnotes.com/">http://paste.edisonnotes.com/</a></li></ul><p>另外，类似 <strong>代码段</strong> 这样的长文本也不利于阅读，同样可以发到第三方平台进行共享。</p><ul><li><a href="http://dpaste.com/">http://dpaste.com/</a></li><li><a href="http://paste.ubuntu.com/">http://paste.ubuntu.com/</a></li></ul><p>需要注意，尽管 IRC 频道可加密，甚至可以自建服务器在其之上通信，可确保会话安全，但通讯线路并不加密，需要第三方软件或客户端实现加密，从这一角度上看，IRC 通信安全性并不高。</p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><p>接下来列举几个常见客户端</p><h3 id="pidgin"><a class="markdownIt-Anchor" href="#pidgin"></a> pidgin</h3><p>安装：</p><ol><li>macOS <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew <span class="token function">install</span> adium<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Ubuntu <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> pidgin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Windows 可去 <a href="http://pidgin.im/">主页</a> 下载，注意需使用 offline 版本</li></ol><p>初次使用，需要在菜单-&gt;添加新的账户选择 IRC</p><p><img src="https://s1.ax1x.com/2019/11/19/MRkXbq.jpg" alt="添加账号" /></p><p>昵称任意，主机名可以填国内较快的 <code>irc.ubuntu.com</code></p><p>文件-&gt;加入群组聊天</p><p><img src="https://s1.ax1x.com/2019/11/19/MRkvV0.jpg" alt="加入聊天" /></p><p>填写 <a href="#%E9%A2%91%E9%81%93" title="跳转到频道章节">频道</a> 和密码（大多公共频道无密码）</p><p><img src="https://s1.ax1x.com/2019/11/19/MgOp7R.png" alt="adium 聊天界面" /></p><h3 id="textual"><a class="markdownIt-Anchor" href="#textual"></a> Textual</h3><p><a href="https://www.codeux.com/textual/">主页</a></p><p>可免费全功能试用 30 天，到期后可功能有删减</p><p><img src="https://s1.ax1x.com/2019/11/19/M2YVkF.png" alt="Textual 聊天界面（现在太冷清了" /></p><h3 id="irssi"><a class="markdownIt-Anchor" href="#irssi"></a> Irssi</h3><p><a href="https://irssi.org">主页</a><br /><a href="https://github.com/irssi/irssi">GitHub</a></p><p>轻量级 CLI 客户端</p><p>安装：</p><ol><li>macOS <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew <span class="token function">install</span> irssi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Ubuntu <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> irssi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>快捷键：</p><ul><li><kbd>Alt</kbd>+<kbd>1</kbd>/<kbd>2</kbd>/<kbd>3</kbd>：切换窗口</li><li><kbd>Alt</kbd>+<kbd>N</kbd>/<kbd>P</kbd>：滚动屏幕</li><li><kbd>PageUp</kbd>/<kbd>PageDown</kbd>：上下翻页</li></ul><p>配置文件：<code>~/.irssi/config</code></p><h4 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h4><ol><li>直接带昵称登录指定的服务器 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ irrsi -c <span class="token operator">&lt;</span>server<span class="token operator">></span> <span class="token punctuation">[</span>-p port -n nickname<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>登陆/退出 IRC 服务器 <pre class="line-numbers language-none"><code class="language-none">&#x2F;connect &lt;server&gt; [port]&#x2F;disconnect &lt;server&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>修改昵称 <pre class="line-numbers language-none"><code class="language-none">&#x2F;nick &lt;nickname&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>进入频道 <pre class="line-numbers language-none"><code class="language-none">&#x2F;join &lt;#channel&gt; &lt;password&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查看窗口列表 <pre class="line-numbers language-none"><code class="language-none">&#x2F;window list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>关闭当前窗口 <pre class="line-numbers language-none"><code class="language-none">&#x2F;window close &lt;窗口编号&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>退出应用 <pre class="line-numbers language-none"><code class="language-none">&#x2F;wc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="weechat"><a class="markdownIt-Anchor" href="#weechat"></a> WeeChat</h3><blockquote><p><a href="https://weechat.org" title="主页">WeeChat</a>，Wee Enhanced Environment for Chat</p></blockquote><p>C 语言编写的 CLI 客户端，具有扩展性，支持 Python、Perl、Ruby</p><p>该项目仍在更新中，截稿时 <a href="https://weechat.org/download/," title="下载页面">最新版</a> 为 v2.6（Sep 8, 2019）</p><p>安装：</p><ol><li>macOS <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew <span class="token function">install</span> weechat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Ubuntu <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> weechat <span class="token function">screen</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Arch <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pacman -S weechat <span class="token function">screen</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ul><li>连接到服务器  <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;connect freenode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>自动连接到 freenode：</p><ol><li>添加一个 server <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;server add freenode &lt;chat.freenode.net&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>设置自动连接到 freenode <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;set irc.server.freenode.autoconnect on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><s>东西有点多，此处简单记下，日后慢慢体验（逃</s></p><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ul><li><a href="https://www.mirc.com">mIRC</a>：Windows 客户端<br /><img src="https://s1.ax1x.com/2019/11/19/M2YefJ.jpg" alt="#b# 图片来自网络" /><br /><img src="https://s1.ax1x.com/2019/11/19/M2Ynp9.jpg" alt="#b# 图片来自网络" /></li><li>irccloud：iOS/Android 客户端</li><li><a href="http://www.androirc.com/zh/">AndroidIRC</a>：Android 客户端</li><li>Hexchat</li><li>xchat</li></ul><p><s>IRC 毕竟曾经火过，衍生产品不少，只不过大多较为古老罢了。</s></p><h2 id="常用命令-2"><a class="markdownIt-Anchor" href="#常用命令-2"></a> 常用命令</h2><p>RFC 规定了 IRC 命令规范，详询 <a href="https://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands" title="维基百科">List of Internet Relay Chat commands</a></p><p><a href="https://wiki.ubuntu.org.cn/IRC%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E">Ubuntu 中文</a> 给出了一些命令说明。</p><p>常见的 IRC 命令有以下几个，但不同平台的实现各有不同，具体需要参考相关说明。</p><p>注册频道、昵称等命令以 freenode 为例 <s>，毕竟目前（2019 年）稳定较为活跃的平台也就这么点</s>，该平台提供了一些服务，可用来进行操作，如：</p><ul><li>昵称操作使用 <code>NickServ</code></li><li>频道操作使用 <code>ChanServ</code></li></ul><p>其实相当于一个用户</p><p><img src="https://s1.ax1x.com/2019/11/19/M2YATU.png" alt="#b# ChanServ 管理员" /></p><p><a href="#irssi">irssi</a> 和 <a href="#weechat">Weechat</a> 等命令行界面常用命令大同小异，但各自又有不同，可简单参照 <s>，挖个坑，先把 GUI 玩好了，之后再把玩 CLI</s>。</p><h3 id="连接到网络"><a class="markdownIt-Anchor" href="#连接到网络"></a> 连接到网络</h3><p>连接到 IRC 服务器 <code>server</code></p><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;server &lt;server&gt;&#x2F;connect &lt;server&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="频道-2"><a class="markdownIt-Anchor" href="#频道-2"></a> 频道</h3><h4 id="加入频道"><a class="markdownIt-Anchor" href="#加入频道"></a> 加入频道</h4><p>进入 <code>#channel</code> 频道</p><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;part &lt;#channel&gt;&#x2F;join &lt;#channel&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="退出频道"><a class="markdownIt-Anchor" href="#退出频道"></a> 退出频道</h4><p>离开 <code>#channel</code> 频道，可留下离开的原因 <code>reason</code></p><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;quit &lt;#channel&gt; [reason]&#x2F;leave &lt;#channel&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="暂时离开"><a class="markdownIt-Anchor" href="#暂时离开"></a> 暂时离开</h4><p>告诉别人暂时离开，当别人小窗你时将得到 <code>reason</code> 的消息</p><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;away &lt;reason&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="注册频道"><a class="markdownIt-Anchor" href="#注册频道"></a> 注册频道</h4><ol><li>进入（临时）频道 <code>#channel</code> <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;join &lt;#channel&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>设定密码 <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;msg ChanServ register &lt;#channel&gt; &lt;password&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="用户"><a class="markdownIt-Anchor" href="#用户"></a> 用户</h3><h4 id="注册昵称"><a class="markdownIt-Anchor" href="#注册昵称"></a> 注册昵称</h4><ol><li>更改密码为 <code>password</code>, 邮箱为 <code>me@gmail.com</code> <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;msg ChanServ register &lt;password&gt; &lt;me@gmail.com&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>登录： <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;msg ChanServ identify &lt;password&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="更换昵称"><a class="markdownIt-Anchor" href="#更换昵称"></a> 更换昵称</h4><p>进入 IRC 服务器后，可修改昵称</p><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;nick &lt;newName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="管理"><a class="markdownIt-Anchor" href="#管理"></a> 管理</h3><h4 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h4><ul><li>查看 <code>nick</code> 用户的信息  <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;who &lt;nick&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查看 <code>IP</code> 登录  <pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;who &lt;IP&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="踢出用户"><a class="markdownIt-Anchor" href="#踢出用户"></a> 踢出用户</h4><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;kick &lt;#channel&gt; &lt;nick&gt; &lt;reason&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更改话题"><a class="markdownIt-Anchor" href="#更改话题"></a> 更改话题</h4><pre class="line-numbers language-irc" data-language="irc"><code class="language-irc">&#x2F;topic &lt;#channel&gt; &lt;topic&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr /><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>以上就是 IRC 的大致情况和基本用法，相信仍有一些不当之处，欢迎指正。</p><p>可以看到，虽然 IRC 在现在的中国互联网已然没落，但因其简单、自由的性质，在极客圈中仍有不少追随者。IRC 服务器可作为一个节点加入 IRC 网络，因此，自建服务器也是可行的。得益于 IRC 协议的开放性，自建服务器也有多种方案，如 UnrealIRCd。</p><blockquote><p><a href="https://www.unrealircd.org" title="主页">UnrealIRCd</a> is an Open Source IRC Server, serving thousands of networks since 1999.</p></blockquote><p>借助此项目建立私有的服务器，可使得信息不被不公开（首先得确保网络通信也是安全的）</p><p><s>想想也是挺有意思的，此处挖个坑，尝试自建一个 IRC 服务器。</s></p><p>在互联网通信高度发达的 9102 年，我在此挖掘几年甚至十几年前的技术似乎不合时宜，尽管如此，但 IRC 技术自身并非一无是处，某些特性甚至具有先进性，故仍具有其存在的意义。</p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://blog.csdn.net/john_cdy/article/details/7742218">如何使用IRC</a></li><li><a href="https://www.cnblogs.com/tsdxdx/p/7291877.html">命令行 IRC 客户端 irssi 的基本操作</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IRC </tag>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPDK 工具</title>
      <link href="2019/04/dpdk-gong-ju/"/>
      <url>2019/04/dpdk-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>DPDK 中提供了一些工具用来测试，本文对此进行一些简单的介绍，以期抛砖引玉。</p><ul><li>操作环境同上篇。虚拟机分配 4 个核心<ul><li>系统：CentOS 7 Kernel 3.10</li><li>架构：IA，64 位，4 核</li><li>内存：1 GB</li><li>DPDK 版本：18.11.1 LTS</li><li>网卡：使用 VirtualBox 虚拟机的 Intel 82540EM</li></ul></li><li>DPDK 提供的工具大多为实例，因此具有 EAL，在运行时需注意传入参数</li><li>大多实例需要两个以上核心，一个核用来管理命令行等信息，另外的核用来处理数据包</li><li>实例的运行可能需要 root 权限，建议使用 root 账户操作</li></ul><h2 id="testpmd"><a class="markdownIt-Anchor" href="#testpmd"></a> TestPMD</h2><ul><li>功能：在网络接口的以太网端口之间转发数据包。TestPMD 随 DPDK 库和工具一同编译，无需另外安装</li><li>路径：<code>&lt;RTE_SDK&gt;/&lt;RTE_TARGET&gt;</code>，此处为 <code>/dpdk/x86_64-native-linuxapp-gcc</code></li></ul><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>设置方式：</p><ul><li>将两个端口连接到外部流量生成器</li><li>使用回送模式下的两个端口接在一起</li></ul><p>转发模式：</p><ul><li>输入/输出：默认。通常称为 IO 模式，在内核接收一个端口的数据包（Rx）并将其传输到里一个端口（Tx）</li><li>仅 Rx：轮询来自 Rx 端口的数据包</li><li>仅 Tx：生成 64 字节的 IP 数据包并在 Rx 端口传输</li></ul><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><ol><li>设置 Hugepages、加载 UIO 驱动、绑定端口</li><li>运行程序。TestPMD 默认在非交互模式下运行，指定<code>-i</code> 可交互 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> /build/app/testpmd/test-pmd –l <span class="token number">2,3</span>,4 –n <span class="token number">4</span> -- -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-l</code>：指定逻辑核心，核心 2 用于管理命令行，核心 3 和 4 将用于转发分组</li><li><code>-n</code>：指定系统的内存通道数</li></ul></li></ol><p>稍等片刻即可进入命令行交互界面。</p><h3 id="常用参数"><a class="markdownIt-Anchor" href="#常用参数"></a> 常用参数</h3><ul><li><code>--nb-cores=N</code>：设置转发核心数，其中 1≤N≤核心数，默认 1</li><li><code>--nb-ports=N</code>：设置转发端口的数量，其中 1≤N≤端口数</li><li><code>--coremask=0xXX</code>：设置转发测试核心的十六进制掩码。主 lcore 仅保留用于命令行解析</li><li><code>--portmask=0xXX</code>：设置转发测试的端口的十六进制掩码</li><li><code>--eth-peer=N,XX:XX:XX:XX:XX:XX</code>：设置端口 N 的 MAC 地址</li><li><code>--tx-ip=SRC,DST</code>：设置仅进行传输测试时使用的源和目的地址</li></ul><h3 id="常用运行时命令"><a class="markdownIt-Anchor" href="#常用运行时命令"></a> 常用运行时命令</h3><ul><li>检查配置  <pre class="line-numbers language-none"><code class="language-none">show config fwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>开始/停止 转发  <pre class="line-numbers language-none"><code class="language-none">start &#x2F; stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>显示应用程序正在使用的所有端口的统计信息：  <pre class="line-numbers language-none"><code class="language-none">show port stats all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用多个内核  <pre class="line-numbers language-none"><code class="language-none">set nbcore 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="pktgen-dpdk"><a class="markdownIt-Anchor" href="#pktgen-dpdk"></a> Pktgen-dpdk</h2><p>Pktgen-dpdk（Packet Generator）是一个基于 DPDK 开发的发包工具，因此也可以认为是一个实例，详询 <a href="https://pktgen-dpdk.readthedocs.io/en/latest/commands.html">官方文档</a>。</p><h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><ol><li>安装 Lua <a href="https://www.lua.org/manual/5.3/readme.html">文档</a><br />CentOS 7 所包含的 Lua 版本过低(5.1.x)，需要自行安装，此处使用 Lua 5.3.5 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /usr/local/src$ <span class="token function">wget</span> http://www.lua.org/ftp/lua-5.3.5.tar.gz$ <span class="token function">tar</span> zxf lua-5.3.0.tar.gz$ <span class="token builtin class-name">cd</span> lua-5.3.0$ <span class="token function">make</span> <span class="token operator">&lt;</span>platform<span class="token operator">></span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>&lt;platform&gt;</code> 可选如下平台： <pre class="line-numbers language-none"><code class="language-none">aix bsd c89 freebsd generic linux macosx mingw posix solaris<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>此处为 <code>linux</code></li><li>安装依赖<br />根据情况，CentOS 7 可能需要安装一些依赖才能编译，具体版本就不给出了 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> libpcap-dev$ yum <span class="token function">install</span> libreadline-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>设置环境变量 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">RTE_SDK</span><span class="token operator">=</span>~/dpdk$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">RTE_TARGET</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>进入 pktgen 目录，编译 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>pktgen-dir<span class="token operator">></span>$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="启动-2"><a class="markdownIt-Anchor" href="#启动-2"></a> 启动</h3><ol><li>可使用 <code>tools/run.py</code> 设置启动环境，该 Python 脚本尝试配置系统，内部有提权操作，因而不需要 <em>sudo</em>。 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./tools/run.py default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>该命令需在 pktgen 顶级目录下运行，使用 <code>/cfg/default.cfg</code> 配置文件</li><li>启动<br />启动参数包含 EAL 和自身参数，用 <code>--</code> 分隔，将进入命令行 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> ./pktgen -l <span class="token number">0</span>-1 -n <span class="token number">3</span> -- -P -T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>pktgen 需要至少两个逻辑内核才能运行</li></ol><h3 id="常用参数-2"><a class="markdownIt-Anchor" href="#常用参数-2"></a> 常用参数</h3><ul><li><code>-f</code>：指定脚本，<code>.pkt</code> 或 <code>.lua</code></li><li><code>-l</code>：指定日志文件</li><li><code>-p</code>：指定端口</li><li><code>-P</code>：在所有端口启用混杂模式</li><li><code>-T</code>：彩色终端输出</li><li><code>-G</code>：启用 socket</li><li><code>-N</code>：启用 NUMA 支持</li><li><code>-s&lt;P&gt;:&lt;file&gt;</code>：要传输的端口和 PCAP 文件</li><li><code>-m &lt;string&gt;</code>：将端口映射到核心<ul><li><code>:</code> 表示分别</li><li><code>-</code> 表示和</li><li>[Core].[Port]</li><li>[rx:tx]</li></ul>  <pre class="line-numbers language-none"><code class="language-none">1.0, 2.1, 3.2[1:2].0[1:2].[0-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="常见运行时命令"><a class="markdownIt-Anchor" href="#常见运行时命令"></a> 常见运行时命令</h3><ul><li>set  <pre class="line-numbers language-none"><code class="language-none">set &lt;portlist&gt; &lt;command&gt; value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>command 参数：<ul><li><code>count</code>：发送报文的数量</li><li><code>size</code>：报文大小</li><li><code>rate</code>：发送报文的速率</li><li><code>sport</code>：TCP 源端口号</li><li><code>dport</code>：TCP 目的端口号</li></ul></li><li>也可设置 MAC 及 IP  <pre class="line-numbers language-none"><code class="language-none">set mac &lt;portlist&gt; &lt;ethaddr&gt;set ip src|dst &lt;portlist&gt; &lt;ipaddr&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li>seq：发送报文信息  <pre class="line-numbers language-none"><code class="language-none">seq &lt;seq#&gt; &lt;portlist&gt; dst_mac src_mac dst_ip src_ip sport dport ipv4|ipv6|vlan udp|tcp|icmp vid pktsize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>save/load：保存/导入当前配置到文件</li></ul><h2 id="pktgen"><a class="markdownIt-Anchor" href="#pktgen"></a> Pktgen</h2><p>pktgen 是一个位于 Linux 内核层的高性能网络测试工具，支持多线程，能产生随机 MAC 地址、IP 地址、UDP 端口号等信息的数据包。</p><ul><li>Linux 发行版默认包含</li><li>pktgen 的配置与统计信息查看都使用 <code>/proc</code> 文件系统的数据写入功能</li></ul><h3 id="启动-3"><a class="markdownIt-Anchor" href="#启动-3"></a> 启动</h3><ol><li>加载内核 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ modprobe pktgen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>在 <code>/proc/net/pktgen</code> 可看见如下内容，文件数由 CPU 决定： <pre class="line-numbers language-none"><code class="language-none">kpktgend_0  kpktgend_1  kpktgend_2  kpktgend_3  pgctrl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>手动运行命令 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"rem_device_all"</span> <span class="token operator">></span> /proc/net/pktgen/kpktgend_0<span class="token builtin class-name">echo</span> <span class="token string">"add_device eth0"</span> <span class="token operator">></span> /proc/net/pktgen/kpktgend_0<span class="token builtin class-name">echo</span> <span class="token string">"pkt_size 1000"</span> <span class="token operator">></span> /proc/net/pktgen/eth0<span class="token builtin class-name">echo</span> <span class="token string">"count 1000"</span> <span class="token operator">></span> /proc/net/pktgen/eth0<span class="token builtin class-name">echo</span> <span class="token string">"delay 1"</span> <span class="token operator">></span> /proc/net/pktgen/eth0<span class="token builtin class-name">echo</span> <span class="token string">"src 10.180.80.179"</span> <span class="token operator">></span> /proc/net/pktgen/eth0<span class="token builtin class-name">echo</span> <span class="token string">"dst 10.180.80.181"</span> <span class="token operator">></span> /proc/net/pktgen/eth0<span class="token builtin class-name">echo</span> <span class="token string">"start"</span> <span class="token operator">></span> /proc/net/pktgen/pgctrl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>pkt_size</code>：包长</li><li><code>count</code>：发包个数</li><li><code>delay</code>：时间间隔，单位是纳秒</li></ul></li><li>也可使用命令构建脚本</li></ol><h3 id="常见命令"><a class="markdownIt-Anchor" href="#常见命令"></a> 常见命令</h3><h4 id="控制命令"><a class="markdownIt-Anchor" href="#控制命令"></a> 控制命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>所有线程开始发送</td></tr><tr><td>stop</td><td>停止</td></tr></tbody></table><h4 id="线程的控制命令"><a class="markdownIt-Anchor" href="#线程的控制命令"></a> 线程的控制命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>add_device</td><td>添加某个端口到某个线程</td></tr><tr><td>rem_device_all</td><td>删除绑定在某个线程的所有端口</td></tr><tr><td>max_before_softirq</td><td>在最多发送多少个数据包后,执行 do_softirq()</td></tr></tbody></table><h4 id="端口命令"><a class="markdownIt-Anchor" href="#端口命令"></a> 端口命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>debug</td><td>调试</td></tr><tr><td>clone_skb</td><td>对每个 skb 进行多少个复制，0 表示不复制</td></tr><tr><td>clear_counters</td><td>清空计数器，默认自动清空</td></tr><tr><td>pkt_size</td><td>链路包的大小（除去CRC的值）</td></tr><tr><td>min_pkt_size</td><td>数据包最小值</td></tr><tr><td>max_pkt_size</td><td>数据包最大值</td></tr><tr><td>flags</td><td>包的分片数量</td></tr><tr><td>count</td><td>发送数据包的个数，0 表示一直发送</td></tr><tr><td>delay</td><td>发送两个数据包之间的延时</td></tr><tr><td>dst</td><td>目的 IP</td></tr><tr><td>dst_min</td><td>目的 IP 的最小值</td></tr><tr><td>dst_max</td><td>目的 IP 的最大值</td></tr><tr><td>src_min</td><td>源 IP 最小值</td></tr><tr><td>src_max</td><td>源 IP 最大值</td></tr><tr><td>dst6</td><td>目的 IPv6 地址</td></tr><tr><td>src6</td><td>源 IPv6 地址</td></tr><tr><td>dstmac</td><td>目的 MAC</td></tr><tr><td>srcmac</td><td>源 MAC</td></tr><tr><td>src_mac_count</td><td>源 MAC 的数量，从 srcmac 的 MAC 开始轮询</td></tr><tr><td>dst_mac_count</td><td>目的 MAC 的数量，从 srcmac 的 MAC 开始轮询</td></tr><tr><td>udp_src_min</td><td>最小源 UDP 端口号</td></tr><tr><td>udp_src_max</td><td>最大源 UDP 端口号</td></tr><tr><td>udp_dst_min</td><td>最小目的 UDP 端口号</td></tr><tr><td>udp_dst_max</td><td>最大目的 UDP 端口号</td></tr><tr><td>flows</td><td>并发流的个数</td></tr><tr><td>flowlen</td><td>流的长度</td></tr></tbody></table><h4 id="flags"><a class="markdownIt-Anchor" href="#flags"></a> Flags</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>IPSRC_RND</td><td>PSRC_RND 源 IP 随机发送</td></tr><tr><td>IPDST_RND</td><td>IPDST_RND 源 IP 随机发送</td></tr><tr><td>TXSIZE_RND</td><td>YXSIZE_RND 源 IP 随机发送</td></tr><tr><td>UDPSRC_RND</td><td>UDPSRC_RND 源 IP 随机发送</td></tr><tr><td>UDPDST_RND</td><td>UDPDST_RND 源 IP 随机发送</td></tr><tr><td>MACSRC_RND</td><td>MACSRC_RND 源 IP 随机发送</td></tr><tr><td>MACDST_RND</td><td>MACDST_RND 源 IP 随机发送</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法</title>
      <link href="2019/04/markdown-yu-fa/"/>
      <url>2019/04/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>本文不是 Markdown 入门教程，而是收录各种 Markdown 编辑器的语法及快捷键，方便查询和扩展</p><p>目前整理收录了以下语法：</p><ul><li>GitHub</li><li>有道云笔记</li><li>VSCode 的 Markdown Preview Enhanced</li><li>VSCode 的 Markdown All in One</li></ul><h2 id="常用语法"><a class="markdownIt-Anchor" href="#常用语法"></a> 常用语法</h2><h3 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h3><ol><li>使用 N 个 <code>#</code> 表示 N 级标题，填上空格，可闭合</li><li>类 Setext：<code>=</code> 最高阶标题；<code>-</code> 第二阶标题</li></ol><h3 id="斜体"><a class="markdownIt-Anchor" href="#斜体"></a> 斜体</h3><p>内容两端使用 <code>*</code>，且不加空格，即 HTML 中的 <code>&lt;em&gt;</code><br /><code>*内容*</code> =&gt; <em>内容</em></p><h3 id="粗体"><a class="markdownIt-Anchor" href="#粗体"></a> 粗体</h3><p>内容两端使用 <code>*</code>，且不加空格，即 HTML 中的 <code>&lt;strong&gt;</code><br /><code>**文字</code> =&gt; <strong>文字</strong></p><h3 id="删除线"><a class="markdownIt-Anchor" href="#删除线"></a> 删除线</h3><p>内容两端使用 <code>~~</code>，且不加空格<br /><code>~~Word~~</code> =&gt; <s>Word</s></p><h3 id="分割线"><a class="markdownIt-Anchor" href="#分割线"></a> 分割线</h3><p>使用三个及以上的 <code>*</code>/<code>-</code>/<code>_</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token hr punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示为：</p><hr /><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><ul><li>使用 <code>*</code>/<code>+</code>/<code>-</code>，符号和内容空一格 <code></code></li></ul><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><ul><li>数字加点<code>.</code>，空一格 <code></code>再填写内容，可嵌套 Markdown 语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> A    <span class="token list punctuation">1.</span> a    <span class="token list punctuation">2.</span> b    <span class="token list punctuation">-</span> c<span class="token list punctuation">2.</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示如下：</p><ol><li>A<ol><li>a</li><li>b</li></ol><ul><li>b</li></ul></li><li>B</li></ol><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><ul><li>使用 <code>&gt;</code> 表示说明的文本</li><li>可多层嵌套 Markdown 语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">></span> This is quote<span class="token blockquote punctuation">> ></span> This is <span class="token italic"><span class="token punctuation">*</span><span class="token content">quote</span><span class="token punctuation">*</span></span> in quote<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显示如下：</p><blockquote><p>This is quote</p></blockquote><blockquote><blockquote><p>This is <em>quote</em> in quote</p></blockquote></blockquote><h3 id="嵌套缩进"><a class="markdownIt-Anchor" href="#嵌套缩进"></a> 嵌套缩进</h3><p><a href="#%E5%88%97%E8%A1%A8">列表</a>与<a href="#%E5%BC%95%E7%94%A8">引用</a>的嵌套语法相同</p><ul><li>列表多段落用 1~3 空格 <code></code> 或 1 Tab</li><li>列表内引用 <code>&gt;</code> 缩进 1 次</li><li>列表内引用代码缩进 2 次</li></ul><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><h3 id="行内式"><a class="markdownIt-Anchor" href="#行内式"></a> 行内式</h3><ul><li><code>[]</code> 内注明显示的文本</li><li><code>()</code> 内填写 URI，可以是本文档的内容</li><li><code>&quot; &quot;</code> 内填写鼠标悬停时的说明，需与链接空一格</li></ul><p>代码</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">This is <span class="token url">[<span class="token content">Bing</span>](<span class="token url">http://www.bing.com/</span> <span class="token string">"Bing"</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示为：</p><p>This is <a href="http://www.bing.com/" title="Bing">Bing</a></p><h3 id="参考式"><a class="markdownIt-Anchor" href="#参考式"></a> 参考式</h3><ul><li>在文件的 <strong>任意</strong> 处，定义标记的链接内容</li><li>用 ID 作为索引，可以是数字、文本符号</li><li><code></code>（title）可放到下一行，也可以缩进</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">This is <span class="token url">[<span class="token content">Bing</span>][<span class="token variable">ID</span>]</span><span class="token comment">&lt;!-- 注意需至少空一行，不过写在一起也就失去了参考式的价值了 --></span><span class="token url-reference url"><span class="token punctuation">[</span><span class="token variable">ID</span><span class="token punctuation">]</span><span class="token punctuation">:</span> http://www.bing.com/ <span class="token string">"Bing"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>显示为：</p><p>This is <a href="http://www.bing.com/" title="Bing">Bing</a></p><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ol><li>在文章前填写 <code>[TOC]</code></li><li>使用 <a href="%E5%88%97%E8%A1%A8">列表</a> 加 <a href="#%E9%93%BE%E6%8E%A5">链接</a> 的形式</li><li>MPE：在任意位置插入 <code>&lt;!-- @import &quot;[TOC]&quot; &#123;cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false&#125; --&gt;</code></li></ol><h3 id="注脚"><a class="markdownIt-Anchor" href="#注脚"></a> 注脚</h3><p>使用 <code>[^ID]</code> 表示注脚</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 一个注脚[^footnote]的样例<span class="token list punctuation">2.</span> 第二个注脚[^footnote2]的样例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显示为：</p><ol><li>一个注脚<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的样例</li><li>第二个注脚<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>的样例</li></ol><h2 id="图像"><a class="markdownIt-Anchor" href="#图像"></a> 图像</h2><h3 id="uri"><a class="markdownIt-Anchor" href="#uri"></a> URI</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">描述</span>](<span class="token url">URI</span> <span class="token string">"悬停时的注释"</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>描述</code> 为网络出错时的文字叙述</li><li><code>URI</code> 之后空一格，填写鼠标悬停时的注释</li><li><code>URI</code> 可以为网络资源，也可以是本地图片</li></ul><h3 id="base64"><a class="markdownIt-Anchor" href="#base64"></a> <em>base64</em></h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>data:img/扩展名;base64,base64编码<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因 <em>Base64</em> 较长，故可用<a href="#%E5%8F%82%E8%80%83%E5%BC%8F">参考式</a>的方式将 <em>Base64</em> 字符串置于文章末尾</p><h3 id="img-标签"><a class="markdownIt-Anchor" href="#img-标签"></a> <code>&lt;img&gt;</code> 标签</h3><p>Markdown 兼容 <em>HTML</em> 标记语言，可使用 <em>HTML</em> 的 <code>div</code> 标签</p><ul><li>大小  <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">height</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>200<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>图片名称<span class="token punctuation">"</span></span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>center</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>居中  <pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;div  align=<span class="token string">"center"</span>>...&lt;/div><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h2><ol><li>行内代码块：`</li><li>非代码：```</li><li>代码块：<ol><li>4 空格 或 1 Tab 缩进</li><li>1 对 ``` 跨行引用</li></ol></li></ol><h3 id="扩展语法"><a class="markdownIt-Anchor" href="#扩展语法"></a> 扩展语法</h3><ol><li>语法高亮：在代码块前的 ``` 行注明</li><li>行号显示：<code>&#123;class:&quot;line-numbers&quot;&#125;</code></li></ol><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><p>基于 HTML，可以用相关 <code>&lt;table&gt;</code> 标签创建多种样式</p><ul><li>用 <code>|</code>、<code>-</code>标记表格</li><li>栏与栏间用 <code>|</code></li><li>标题行与数据行用 <code>-</code> 分隔</li></ul><h3 id="markdown"><a class="markdownIt-Anchor" href="#markdown"></a> Markdown</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token table"><span class="token table-header-row"><span class="token punctuation">|</span><span class="token table-header important"> 项目   </span><span class="token punctuation">|</span><span class="token table-header important"> 价格   </span><span class="token punctuation">|</span><span class="token table-header important"> 数量 </span><span class="token punctuation">|</span></span><span class="token table-line"><span class="token punctuation">|</span> <span class="token punctuation">-----</span> <span class="token punctuation">|</span> <span class="token punctuation">------</span> <span class="token punctuation">|</span> <span class="token punctuation">----</span> <span class="token punctuation">|</span></span><span class="token table-data-rows"><span class="token punctuation">|</span><span class="token table-data"> 手机   </span><span class="token punctuation">|</span><span class="token table-data"> \$12   </span><span class="token punctuation">|</span><span class="token table-data"> 12   </span><span class="token punctuation">|</span><span class="token punctuation">|</span><span class="token table-data"> 管线   </span><span class="token punctuation">|</span><span class="token table-data"> \$1    </span><span class="token punctuation">|</span><span class="token table-data"> 234  </span><span class="token punctuation">|</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显示为：</p><table><thead><tr><th>项目</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>手机</td><td>$12</td><td>12</td></tr><tr><td>管线</td><td>$1</td><td>234</td></tr></tbody></table><h3 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>项目<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>价格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>星期<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>计算机<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>$1600<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示为：</p><table>    <tr>        <th>项目</th>        <th>价格</th>        <th>星期</th>    </tr>    <tr>        <td>计算机</td>        <td>$1600</td>        <td>5</td>    </tr>    <tr>        <td>移动硬盘</td>        <td>$80</td>        <td>50</td>    </tr></table><h2 id="todo-列表"><a class="markdownIt-Anchor" href="#todo-列表"></a> Todo 列表</h2><ul><li><code>[ ]</code>（未完成）或 <code>[x]</code>（已完成）</li><li>支持子列表嵌套 Markdown 语法</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">-</span> [ ] <span class="token bold"><span class="token punctuation">**</span><span class="token content">Markdown 开发</span><span class="token punctuation">**</span></span>    <span class="token list punctuation">-</span> [ ] 支持以 PDF 格式导出文稿    <span class="token list punctuation">-</span> [x] 新增 Todo 列表功能    <span class="token list punctuation">-</span> [x] 改进 LaTex 功能        <span class="token list punctuation">-</span> [x] 修复 LaTex 公式渲染问题        <span class="token list punctuation">-</span> [x] 新增 LaTex 公式编号功能<span class="token list punctuation">-</span> [ ] <span class="token bold"><span class="token punctuation">**</span><span class="token content">七月旅行准备</span><span class="token punctuation">**</span></span>    <span class="token list punctuation">-</span> [ ] 准备邮轮上需要携带的物品    <span class="token list punctuation">-</span> [x] 购买七月一日的船票<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示如下：</p><ul><li>[ ] <strong>Markdown 开发</strong><ul><li>[ ] 支持以 PDF 格式导出文稿</li><li>[x] 新增 Todo 列表功能</li><li>[x] 改进 LaTex 功能<ul><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能</li></ul></li></ul></li><li>[ ] <strong>七月旅行准备</strong><ul><li>[ ] 准备邮轮上需要携带的物品</li><li>[x] 购买七月一日的船票</li></ul></li></ul><blockquote><p>本博客所用的解析器貌似不支持 -_-</p></blockquote><h3 id="转义"><a class="markdownIt-Anchor" href="#转义"></a> 转义</h3><ul><li>使用反斜线 <code>\</code>，以下内容可能需转义：<ol><li><code>\\</code> =&gt; \：反斜线</li><li><code>\`` =&gt; \</code>：反引号</li><li><code>\*</code> =&gt; *：星号</li><li><code>\_</code> =&gt; _：底线</li><li><code>\&#123;\&#125;</code> =&gt; {}：花括号</li><li><code>\[\]</code> =&gt; []：方括号</li><li><code>\(\)</code> =&gt; ()：括弧</li><li><code>\#</code> =&gt; #：井字号</li><li><code>\+</code> =&gt; +：加号</li><li><code>\-</code> =&gt; -：减号</li><li><code>\.</code> =&gt; .：英文句点</li><li><code>\!</code> =&gt; !：惊叹号</li></ol></li><li><code>&amp;lt;</code>：<code>&lt;</code></li><li><code>&amp;amp;</code>：<code>&amp;</code></li><li><code>&amp;copy;</code>：<code>©</code></li></ul><h3 id="首行缩进"><a class="markdownIt-Anchor" href="#首行缩进"></a> 首行缩进</h3><ul><li>半方大的空白 <code>&amp;ensp;</code> 或 <code>&amp;#8194</code></li><li>全方大的空白 <code>&amp;emsp;</code> 或  <code>&amp;#8195</code></li><li>不断行的空白格 <code>&amp;nbsp;</code> 或 <code>&amp;#160</code></li></ul><h2 id="扩展语法-2"><a class="markdownIt-Anchor" href="#扩展语法-2"></a> 扩展语法</h2><p><em>Visual Studio Code</em> 插件 Markdown Preview Enhanced</p><ol><li>目录：<ol><li>在任意位置插入 <code>&lt;!-- @import &quot;[TOC]&quot; &#123;cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false&#125; --&gt;</code></li><li>代码 <pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token front-matter-block"><span class="token punctuation">---</span><span class="token font-matter yaml language-yaml">toc:    depth_from:2    depth_to:4    ordered:false</span><span class="token punctuation">---</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li>批注：<ol><li><mark>高亮：</mark> <code>== ==</code></li><li>注释：{&gt;&gt;注释&lt;&lt;}</li><li>下划线：{<ins>下划线内容</ins>}</li></ol></li><li>表格<ul><li><code>^</code> 向上合并单元格，<code>&gt;</code> 向右合并单元格</li></ul></li><li>在文档里运行代码</li><li>导入文件：<code>@import &quot;file&quot;</code></li></ol><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>这是一个 <em>注脚</em> 的 <strong>文本</strong>。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>这是另一个 <em>注脚</em> 的 <strong>文本</strong>。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 参考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPDK 部署</title>
      <link href="2019/04/dpdk-bu-shu/"/>
      <url>2019/04/dpdk-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p><a href="https://www.dpdk.org/">DPDK</a> is the Data Plane Development Kit that consists of libraries to accelerate packet processing workloads running on a wide variety of CPU architectures.</p></blockquote><p>最近用到 <em>Intel©️DPDK</em>，即 Intel Data Plane Development Kit，<a href="http://doc.dpdk.org/guides/index.html">官方文档</a> 挺全面，但是一路跟下来，问题并不少；同时，该工具包本身不是像 ZSH 那样一般常见且常用的工具，各大平台上相关的资料并不算多。故在此将学习的过程记录下来，希望能起到抛砖引玉的作用。</p><h2 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h2><h3 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h3><ul><li>系统：CentOS 7 Kernel 3.10</li><li>架构：IA，64 位</li><li>内存：1 GB</li><li>DPDK 版本：18.11.1 LTS</li><li>网卡：使用 VirtualBox 虚拟机的 Intel 82540EM</li></ul><p>目录结构如下：</p><pre class="line-numbers language-none"><code class="language-none">dpdk-18.11.1├── app├── devtools├── doc├── examples├── kernel├── drivers├── lib├── buildtools├── config├── mk├── license├── pkg├── test└── usertools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装条件"><a class="markdownIt-Anchor" href="#安装条件"></a> 安装条件</h3><ol><li>硬件支持，查询 <a href="http://core.dpdk.org/supported/">网卡支持</a></li><li>查看 CPU 是否支持大页内存技术 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> flags /proc/cpuinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>包含 pge 表示支持 2MB 大页内存</li><li>包含 pdpe1gb 表示支持 1GB 大页内存</li></ul></li><li>查看内存分页情况： <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> Huge /proc/meminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>安装必要依赖 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yum <span class="token function">install</span> numactl-devel*x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>更具体的信息在 <a href="http://doc.dpdk.org/guides/linux_gsg/sys_reqs.html">官方文档</a> 中</p><h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><ol><li><p>设置环境变量<br />将以下内容增加到 <code>~/.bash_profile</code> 或 <code>~/.zshrc</code> 等 <em>shell</em> 配置文件，或者直接输入：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">DPDK_DIR</span><span class="token operator">=</span><span class="token operator">&lt;</span>DPDK-DIR<span class="token operator">></span><span class="token builtin class-name">export</span> <span class="token assign-left variable">DPDK_TARGET</span><span class="token operator">=</span><span class="token operator">&lt;</span>TARGET<span class="token operator">></span><span class="token builtin class-name">export</span> <span class="token assign-left variable">DPDK_BUILD</span><span class="token operator">=</span><span class="token variable">$DPDK_DIR</span>/<span class="token variable">$DPDK_TARGET</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>TARGET</code> 格式为 <code>ARCH-MACHINE-EXECENV-TOOLCHAIN</code></p><ul><li>ARCH: i686，x86_64，ppc_64，arm64</li><li>MACHINE: native，power8，armv8a</li><li>EXECENV: linux，freebsd</li><li>TOOLCHAIN: gcc，icc</li></ul><p>带入变量，命令如下：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">DPDK_DIR</span><span class="token operator">=</span>/root/dpdk$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">DPDK_TARGET</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>编译</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">T</span><span class="token operator">=</span><span class="token operator">&lt;</span>TARGET<span class="token operator">></span>   <span class="token comment"># T 指定编译的目标环境</span>$ <span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">T</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将提示 <code>Installation cannot run with T defined and DESTDIR undefined</code>，即未指定安装位置，此处只需编译，可忽略，目录下多了名为 <code>&lt;TARGET&gt;</code> 的文件夹</p></li></ol><h3 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h3><pre class="line-numbers language-none"><code class="language-none">x86_64-native-linuxapp-gcc    # 即指定的 &lt;TARGET&gt;├── app├── build├── include├── kmod        # 存放内核模块├── lib└── Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="启动环境"><a class="markdownIt-Anchor" href="#启动环境"></a> 启动环境</h2><p>DPDK 可总结如下：</p><ul><li>UIO，Userspace I/O</li><li>Hugepages</li><li>CPU Affinity 机制</li></ul><p>其中一些特性的实现还需要系统环境支持，可使用 DPDK 提供的 <code>usertools/dpdk-setup.sh</code> 脚本来配置</p><h3 id="hugepages"><a class="markdownIt-Anchor" href="#hugepages"></a> hugepages</h3><p>为支持 Hugepages，需要配置内存页。</p><ul><li>若仅使用 2MiB 大页内存<br />输入以下命令，比较灵活方便，但是每次启动都要操作：  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token number">1024</span> <span class="token operator">></span> /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>若使用 VFIO<br />添加以下内容到 <code>/etc/default/grub</code> 的 <code>GRUB_CMDLINE_LINUX</code>：  <pre class="line-numbers language-none"><code class="language-none">hugepages&#x3D;1024  # 对于 2MiB 页面default_hugepagesz&#x3D;1G hugepagesz&#x3D;1G hugepages&#x3D;4 iommu&#x3D;pt intel_iommu&#x3D;on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>更新 grub 并重启  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ grub2-mkconfig -o /boot/grub2/grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>若使用 igb_uio<br />可不开启 <code>iommu</code> 的两个选项</li></ul><p>设置完内存页，需要挂载内存：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> /mnt/huge$ <span class="token function">mount</span> -t hugetlbfs nodev /mnt/huge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将以下命令添加到 <code>/etc/fstab</code> 可以永久保存:</p><pre class="line-numbers language-none"><code class="language-none">nodev &#x2F;mnt&#x2F;huge hugetlbfs defaults 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="加载内核模块"><a class="markdownIt-Anchor" href="#加载内核模块"></a> 加载内核模块</h3><h4 id="uio"><a class="markdownIt-Anchor" href="#uio"></a> UIO</h4><ul><li>Linux 内核所包含的标准 <em>uio_pci_generic</em> 模块可提供 UIO 能力  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> modprobe uio_pci_generic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>DPDK 提供了一个 <em>igb_uio</em> 模块，在 <code>$DPDK_TARGET/kmod</code> 目录  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> modprobe uio$ <span class="token function">sudo</span> insmod <span class="token variable">$DPDK_TARGET</span>/kmod/igb_uio.ko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="vfio"><a class="markdownIt-Anchor" href="#vfio"></a> VFIO</h4><p>Linux 内核从 3.6.0 之后默认包含 <em>VFIO</em> 模块，因此也可使用该模块</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> modprobe vfio-pci<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="绑定端口"><a class="markdownIt-Anchor" href="#绑定端口"></a> 绑定端口</h3><p>DPDK 程序在运行前，需要将所要使用的端口绑定到 <em>uio_pci_generic</em>, <em>igb_uio</em> 或 <em>vfio-pci</em> 模块上</p><ol><li>停用网卡 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ifconfig</span> eth0 down<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>usertools/dpdk-devbind.py</code> 提供当前系统上网络接口的状态，绑定或解绑定来自不同内核模块的接口 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dpdk-devbind.py --status  <span class="token comment"># 查看状态</span>$ dpdk-devbind.py --status-dev eth0 <span class="token comment"># 查看接口状态</span>$ dpdk-devbind.py --bind<span class="token operator">=</span>igb_uio 03:00.0    <span class="token comment"># 绑定接口到 igb_uio 驱动，可使用接口名称</span>$ dpdk-devbind.py -u 0000:03:00.0   <span class="token comment"># 解绑</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="运行实例"><a class="markdownIt-Anchor" href="#运行实例"></a> 运行实例</h2><h3 id="构建"><a class="markdownIt-Anchor" href="#构建"></a> 构建</h3><p>构建实例时，需要导入以下环境变量：</p><ul><li><code>RTE_SDK</code> - 指向 DPDK 安装目录</li><li><code>RTE_TARGET</code> - 指向 DPDK 目标环境目录</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">RTE_SDK</span><span class="token operator">=</span><span class="token operator">&lt;</span>DPDK_DIR<span class="token operator">></span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">RTE_TARGET</span><span class="token operator">=</span><span class="token operator">&lt;</span>RTE_TARGET<span class="token operator">></span>$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为保持项目文件夹纯净，也可将实例放在其他目录以保持 DPDK 目录结构不变<br />此处以 l2fwd 举例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cp</span> ~/dpdk/examples/l2fwd ~/l2fwd-eg$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">RTE_SDK</span><span class="token operator">=</span>~/dpdk$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">RTE_TARGET</span><span class="token operator">=</span>x86_64-native-linuxapp-gcc$ <span class="token builtin class-name">cd</span> ~/l2fwd-eg$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动环境-2"><a class="markdownIt-Anchor" href="#启动环境-2"></a> 启动环境</h3><ol><li><a href="#hugepages">hugepages</a>，若此前永久保存，可略过</li><li><a href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97">加载内核模块</a>，因为 UIO 需要内核支持</li><li><a href="#%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3">绑定端口</a>，DPDK 作用是收发数据包，因此需要配置端口</li></ol><h3 id="eal"><a class="markdownIt-Anchor" href="#eal"></a> EAL</h3><blockquote><p>EAL，Environment Abstraction Layer，环境抽象层</p></blockquote><p>应用程序与 DPDK 目标环境的环境抽象库相关联，也就是说，每个实例运行的参数分为 EAL 参数和自身的参数。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">&lt;</span>example<span class="token operator">></span> -c <span class="token operator">&lt;</span>coremask<span class="token operator">></span> -l <span class="token operator">&lt;</span>corelist<span class="token operator">></span> -n <span class="token number">2</span> -- -i$ l2fwd -c 0x3 -l <span class="token number">2,3</span>,4 -n <span class="token number">2</span> -- -i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用参数：</p><ul><li><code>-c</code>：核心数的十六进制掩码，如 11 对应 0x3<br />读取 <code>/proc/cpuinfo</code> 中的 <code>physical id</code> 可知 core 的信息</li><li><code>-l</code>：逻辑核心列表，第一个核用于管理命令行</li><li><code>-n</code>：内存通道数</li><li><code>--master-lcore</code>：主服务器的核心</li><li><code>-p</code>：端口十六进制掩码</li><li><code>--</code>：分割 EAL 与各实例的参数</li><li><code>-i</code>：某些实例如 <em>testpmd</em> 有可交互的参数</li></ul><p>至此，DPDK 的部署工作基本完成。文章并不详细，算不上教程，没有给出所以然，权当一个记录，若有需要，今后再做补充；如有问题，欢迎讨论。</p><p>工具包提供了不少脚本以供加快进度，同时 <code>/examples</code> 下包含了几十个实例，不得不说，<em>Intel©️DPDK</em> 项目很友好，后续将深入学习。</p>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPDK </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 文件格式</title>
      <link href="2018/12/pe-wen-jian-ge-shi/"/>
      <url>2018/12/pe-wen-jian-ge-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><p>PE 格式是由 <em>Unix</em> 中的 COFF 格式修改而来的，在 Windows 环境中，PE 格式也称为 <em>PE/COFF 格式</em></p><p>在 Win64 系统上运行的原生 64 位应用程序，其 PE 格式称为 <em>PE32+</em>，与 PE 不同之处基本只是在 PE 头 <em>IMAGE_NT_HEADERS</em></p><h3 id="常见格式"><a class="markdownIt-Anchor" href="#常见格式"></a> 常见格式</h3><ul><li>EXE</li><li>DLL（动态链接库）</li><li>SYS（驱动程序）</li><li>COM</li><li>OCX</li><li>EFI</li></ul><h3 id="文件结构概览"><a class="markdownIt-Anchor" href="#文件结构概览"></a> 文件结构概览</h3><pre class="line-numbers language-none"><code class="language-none">|——IMAGE_DOS_HEADER                     | +40h |——e_magic                 4D 5A |——xxx |——e_lfanew   xx xx xx xx|——DOS Stub|——IMAGE_NT_HEADERS                     | |——Signature               50 45 00 00 | +04h |——IMAGE_FILE_HEADER                   | +14h |——IMAGE_OPTIONAL_HEADER               | +224h&#x2F;+240h  |——IMAGE_DATA_DIRECTORY               |  01h x 16|——IMAGE_SECTION_HEADER                 | +28h x (n + 1)|——SECTIONs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ol><li><p>EP</p><blockquote><p>Entry Pointer，入口点</p></blockquote><p>EP是一个RVA，EP + Imagebase = 入口点的VA<br />通常情况下，EP指向的不是main函数</p></li><li><p>OEP</p><blockquote><p>Original Entery Pointer，原始入口点</p></blockquote></li><li><p>INT</p><blockquote><p>Import Name Table，导入名称表，一个结构体数组，详见 <strong>导入表</strong></p></blockquote></li><li><p>对齐<br />文件对齐的最小单位是磁盘扇区的单位，0x0200 字节<br />内存对齐的最小单位是 CPU 内存分页大小，Win32 0x1000 字节，即 4 KiB</p></li><li><p>节偏移<br />内存中数据节相对于装载基址的偏移量(<em>RVA</em>)和文件中数据节的偏移量(<em>FOA</em>)的差异称为节偏移</p></li></ol><h3 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h3><ol><li><p><em>ImageBase</em><br />基地址，磁盘中的文件加载到内存中时可以加载到任意位置，即程序的基址<br />建议装载地址，详见 <strong>重定位表</strong></p><ul><li>EXE 默认加载基址是 <code>0x00400000h</code></li><li>DLL 默认加载基址是 <code>0x10000000h</code></li></ul><blockquote><p>需要注意的是基地址不是程序的入口点</p></blockquote></li><li><p>VA</p><blockquote><p>虚拟地址，Virtual Address</p></blockquote><p>程序运行时被加载到 <strong>内存</strong> 中的地址</p></li><li><p>RVA</p><blockquote><p>相对虚拟地址，Relative Virtual Address</p></blockquote><p>是在内存中相对于 <strong>映射基地址</strong> (EXE 文件为<em>ImageBase</em>)的偏移量</p></li><li><p>FOA</p><blockquote><p>文件偏移地址，File Offset Address</p></blockquote><p>当PE文件储存在某个磁盘当中的时候，某个数据的位置相对于 <strong>文件头</strong> 的偏移量</p></li><li><p>地址转换</p><ol><li>VA = ImageBase + RVA</li><li>FOA = VA - ImageBase - 节偏移</li><li>FOA = RVA - 节偏移</li></ol></li></ol><h2 id="ms-dos-header"><a class="markdownIt-Anchor" href="#ms-dos-header"></a> MS-DOS Header</h2><p>PE 文件第一个字节起始于 MS-DOS 头部，该头部被定义为 <em>IMAGE_DOS_HEADER</em><br />DOS 头部为了兼容 DOS 系统而遗留的，最后一个字节给出了 PE 头的地址</p><h3 id="结构体-image_dos_header"><a class="markdownIt-Anchor" href="#结构体-image_dos_header"></a> 结构体 IMAGE_DOS_HEADER</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typrdef struct _IMAGE_DOS_HEADER &#123;    WORD   e_magic;          &#x2F;&#x2F; +0000h - EXE标志，&quot;MZ&quot;    WORD   e_cblp;           &#x2F;&#x2F; +0002h - 最后（部分）页中的字节数    WORD   e_cp;             &#x2F;&#x2F; +0004h - 文件中的全部和部分页数    WORD   e_crlc;           &#x2F;&#x2F; +0006h - 重定位表中的指针数    WORD   e_cparhdr;        &#x2F;&#x2F; +0008h - 头部尺寸，以段落为单位    WORD   e_minalloc;       &#x2F;&#x2F; +000ah - 所需的最小附加段    WORD   e_maxalloc;       &#x2F;&#x2F; +000ch - 所需的最大附加段    WORD   e_ss;             &#x2F;&#x2F; +000eh - 初始的SS值（相对偏移量）    WORD   e_sp;             &#x2F;&#x2F; +0010h - 初始的SP值    WORD   e_csum;           &#x2F;&#x2F; +0012h - 补码校验值    WORD   e_ip;             &#x2F;&#x2F; +0014h - 初始的IP值    WORD   e_cs;             &#x2F;&#x2F; +0016h - 初始的CS值    WORD   e_lfarlc;         &#x2F;&#x2F; +0018h - 重定位表的字节偏移量    WORD   e_ovno;           &#x2F;&#x2F; +001ah - 覆盖号    WORD   e_res[4];         &#x2F;&#x2F; +001ch - 保留字00    WORD   e_oemid;          &#x2F;&#x2F; +0024h - OEM标识符    WORD   e_oeminfo;        &#x2F;&#x2F; +0026h - OEM信息    WORD   e_res2[10];       &#x2F;&#x2F; +0028h - 保留字    LONG   e_lfanew;         &#x2F;&#x2F; +003ch - PE头相对于文件的偏移地址  &#125; IMAGE_DOS_HEADER, *IMAGE_DOS_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字段解析"><a class="markdownIt-Anchor" href="#字段解析"></a> 字段解析</h3><ol><li><code>e_magic</code><ul><li>占用 <strong>2</strong> 字节</li><li>值：<strong><code>4D 5A</code></strong></li><li>ASCII：<strong><code>MZ</code></strong></li><li>DOS 头的标记位</li><li>即&quot;MZ&quot; Header，<em>Mark Zbikowski</em> 的姓名缩写，他是最初的 MS-DOS 设计者之一</li><li><em>Winnt.h</em> 宏定义如下 <pre class="line-numbers language-C" data-language="C"><code class="language-C"># define IMAGE_DOS_SIGNATURE 0x5A4D  &#x2F;&#x2F; MZ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><code>e_lfanew</code><ul><li>占用 <strong>4</strong> 字节</li><li>这是一个 RVA，代表 PE 文件头到基址的偏移量，可用来找到 PE 文件头的位置</li></ul></li></ol><h3 id="dos-stub"><a class="markdownIt-Anchor" href="#dos-stub"></a> DOS Stub</h3><ul><li>当 Win32 程序在 DOS 下执行时会输出 <code>This program cannot be run in DOS mode</code></li><li>该部分可有可无，可填充其他内容，一般由编译器生成</li><li><code>e_lfanew</code> 到 <code>e_lfanew</code> 所指出的地址之间的内容</li></ul><h2 id="pe-header"><a class="markdownIt-Anchor" href="#pe-header"></a> PE Header</h2><ul><li>PE 头由 <em>IMAGE_NT_HEADERS</em> 结构体定义<ul><li><em>IMAGE_NT_HEADERS</em> 是一个宏定义，有 <strong>32位</strong> 和 <strong>64位</strong> 之别  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _WIN64typedef IMAGE_NT_HEADER64   IMAGE_NT_HEADER;typedef PIMAGE_NT_HEADER64  PIMAGE_NT_HEADER;#elsetypedef IMAGE_NT_HEADER32   IMAGE_NT_HEADER;typedef PIMAGE_NT_HEADER32  PIMAGE_NT_HEADER;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>起始地址由 <code>IMAGE_DOS_HEADER.lfanew</code> 给出</li><li>真正用来装载 Windows 程序</li></ul><h3 id="结构体-image_nt_headers"><a class="markdownIt-Anchor" href="#结构体-image_nt_headers"></a> 结构体 IMAGE_NT_HEADERS</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_NT_HEADERS &#123;    DWORD Signature;                        &#x2F;&#x2F; +0000h - PE00    IMAGE_FILE_HEADER FileHeader;           &#x2F;&#x2F; +0004h - PE 标准头    IMAGE_OPTIONAL_HEADER32 OptionalHeader; &#x2F;&#x2F; +0018h - PE 选项头 &#x2F;&#x2F; IMAGE_OPTIONAL_HEADER64 OptionalHeader;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="signature"><a class="markdownIt-Anchor" href="#signature"></a> Signature</h3><ul><li>判断是否是 PE 文件</li><li>占用 <strong>4</strong> 字节</li><li>ASCII：<strong><code>PE00</code></strong></li><li>值：<strong><code>00 00 45 50</code></strong></li><li>宏定义如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_NT_SIGNATURE 0x00004550   &#x2F;&#x2F; PE00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="fileheader"><a class="markdownIt-Anchor" href="#fileheader"></a> FileHeader</h3><ul><li>描述文件相关信息</li><li><strong>文件头</strong> 由 <code>IMAGE_DOS_HEADER.e_lfanew</code> 指定地址后的 20 个字节</li><li>结构体大小定义如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_SIZEOF_FILE_HEADER    20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="结构体-image_file_header"><a class="markdownIt-Anchor" href="#结构体-image_file_header"></a> 结构体 IMAGE_FILE_HEADER</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_FILE_HEADER &#123;    WORD    Machine;              &#x2F;&#x2F; +0004h - 运行平台    WORD    NumberOfSections;     &#x2F;&#x2F; +0006h - PE中节的数量    DWORD   TimeDateStamp;        &#x2F;&#x2F; +0008h - 文件创建日期和时间    DWORD   PointerToSymbolTable; &#x2F;&#x2F; +000ch - 指向符号表    DWORD   NumberOfSymbols;      &#x2F;&#x2F; +0010h - 符号表中的符号数量    WORD    SizeOfOptionalHeader; &#x2F;&#x2F; +0014h - 选项头结构的长度    WORD    Characteristics;      &#x2F;&#x2F; +0016h - 文件属性&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字段解析-2"><a class="markdownIt-Anchor" href="#字段解析-2"></a> 字段解析</h4><ol><li><code>Machine</code><ul><li><code>0x0000</code>：适用于任何类型处理器</li><li><code>0x01D3</code>：Matsushita AM33 处理器</li><li><code>0x8664</code>：x64 处理器</li><li><code>0x01C0</code>：ARM 小端处理器</li><li><code>0x0EBC</code>：EFI 字节码处理器</li><li><strong><code>0x014C</code>：Intel 32</strong></li><li><strong><code>0x0200</code>：Intel 64</strong></li><li><code>0x9041</code>：Mitsubishi M32R 小端处理器</li><li><code>0x0266</code>：MIPS16 处理器</li><li><code>0x366</code>：带 FPU 的 MIPS 处理器</li><li><code>0x466</code>：带 FPU 的 MIPS16 处理器</li><li><code>0x1F0</code>：PowerPC 小端处理器</li><li><code>0x1F1</code>：带符点运算支持的 PowerPC 处理器</li><li><code>0x166</code>：MIPS 小端处理器</li><li><code>0x1A2</code>：Hitachi SH3 处理器</li><li><code>0x1A3</code>：Hitachi SH3 DSP 处理器</li><li><code>0x1A6</code>：Hitachi SH4 处理器</li><li><code>0x1A6</code>：Hitachi SH5 处理器</li><li><code>0x1C2</code>：Thumb 处理器</li><li><code>0x169</code>：MIPS 小端 WCE v2 处理器</li></ul></li><li><code>TimeDateStamp</code>：自格林尼治 <em>1970.1.1</em> 以来时间</li><li><code>SizeOfOptionalHeader</code>：指定 <strong>IMAGE_OPTIONAL_HEADER</strong> 结构体大小，也是 <strong>32位</strong> 和 <strong>64位</strong> 的区别</li><li><code>Characteristics</code>：指定该文件类型<ul><li>0表明此文件不包含基址重定位信息，因此必须被加载到其首选基地址上。基地址不可用则报错</li><li>1表明此镜像文件是合法的</li><li>2保留，必须为 0</li><li>3 保留，必须为 0</li><li>4 保留，必须为 0</li><li>5应用程序可以处理大于 2GB 的地址</li><li>6保留，必须为 0</li><li>7保留，必须为 0</li><li>8机器类型基于 32 位体系结构</li><li>9调试信息已经从此镜像文件中移除</li><li>10 如果此镜像文件在可移动介质上，完全加载它并把它复制到交换文件中。几乎不用</li><li>11 如果此镜像文件在网络介质上，完全加载它并把它复制到交换文件中。几乎不用</li><li>12 此镜像文件是系统文件，而不是用户程序</li><li>13 此镜像文件是 DLL</li><li>14 此文件只能运行于单处理器机器上</li><li>15 保留，必须为 0</li></ul></li></ol><h3 id="optionalheader"><a class="markdownIt-Anchor" href="#optionalheader"></a> OptionalHeader</h3><ul><li>选项头，通常称为 “可选头”</li><li>管理 PE 文件装载时所需的文件</li><li>宏定义如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _WIN64typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER     IMAGE_SIZEOF_NT_OPTIONAL64_HEADER#define IMAGE_NT_OPTIONAL_HDR_MAGIC         MAGE_NT_OPTIONAL_HDR64_MAGIC#elsetypedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER     IMAGE_SIZEOF_NT_OPTIONAL32_HEADER#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>大小由 <code>IMAGE_FILE_HEADER.SizeOfOptionalHeader</code> 给出<ul><li>宏定义如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_SIZEOF_NT_OPTIONAL32_HEADER 224#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER 240#define IMAGE_NT_OPTIONAL_HDR32_MAGIC   0x10b#define IMAGE_NT_OPTIONAL_HDR64_MAGIC   0x20b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>32位：<code>0x00E0</code> 字节，即 224 字节</li><li>64位：<code>0x00F0</code> 字节，即 240 字节</li><li>区别：整体增加 16 字节<ol><li><code>BaseOfData</code> 64 位版本不存在</li><li><code>ImageBase</code>、<code>SizeOfStackReserve</code>、<code>SizeOfStackCommit</code>、<code>SizeOfHeapReserve</code>、<code>SizeOfHeapCommit</code> 字段由 4 字节变为 8 字节</li></ol></li></ul></li><li>通常结束于 <code>.text</code> 节之前</li></ul><h4 id="结构体-image_optional_header"><a class="markdownIt-Anchor" href="#结构体-image_optional_header"></a> 结构体 IMAGE_OPTIONAL_HEADER</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_OPTIONAL_HEADER &#123;    &#x2F;&#x2F;    &#x2F;&#x2F; Standard fields.    &#x2F;&#x2F;    WORD    Magic;                 &#x2F;&#x2F; +0018h - 指定文件标识    BYTE    MajorLinkerVersion;    &#x2F;&#x2F; +001ah - 链接器主版本号    BYTE    MinorLinkerVersion;    &#x2F;&#x2F; +001bh - 连接器次版本号    DWORD   SizeOfCode;            &#x2F;&#x2F; +001ch - 所有含代码的节的总大小    DWORD   SizeOfInitializedData;   &#x2F;&#x2F; +0020h - 所有含已初始化数据的节的总大小    DWORD   SizeOfUninitializedData; &#x2F;&#x2F; +0024h - 所有含未初始化数据的节的大小    DWORD   AddressOfEntryPoint;     &#x2F;&#x2F; +0028h - 程序执行入口RVA    DWORD   BaseOfCode;            &#x2F;&#x2F; +002ch - 代码节的起始RVA    DWORD   BaseOfData;            &#x2F;&#x2F; +0030h - 数据节的起始RVA&#x2F;&#x2F; 该字段 64 位版本将不存在    &#x2F;&#x2F;    &#x2F;&#x2F; NT additional fields.    &#x2F;&#x2F;    DWORD   ImageBase;             &#x2F;&#x2F; +0034h - 程序的建议装载地址&#x2F;&#x2F;ULONGLONG ImageBase;    DWORD   SectionAlignment;      &#x2F;&#x2F; +0038h - 内存中节的对齐粒度    DWORD   FileAlignment;         &#x2F;&#x2F; +003ch - 文件中节的对齐粒度    WORD    MajorOperatingSystemVersion; &#x2F;&#x2F; +0040h - 操作系统主版本号    WORD    MinorOperatingSystemVersion; &#x2F;&#x2F; +0042h - 操作系统次版本号    WORD    MajorImageVersion;     &#x2F;&#x2F; +0044h - 该PE主版本号    WORD    MinorImageVersion;     &#x2F;&#x2F; +0046h - 该PE次版本号    WORD    MajorSubsystemVersion; &#x2F;&#x2F; +0048h - 子系统的主版本号    WORD    MinorSubsystemVersion; &#x2F;&#x2F; +004ah - 子系统的次版本号    DWORD   Win32VersionValue;     &#x2F;&#x2F; +004ch - 保留    DWORD   SizeOfImage;           &#x2F;&#x2F; +0050h - 内存中的整个PE映像大小    DWORD   SizeOfHeaders;         &#x2F;&#x2F; +0054h - 所有头+节表的大小    DWORD   CheckSum;              &#x2F;&#x2F; +0058h - 校验和    WORD    Subsystem;             &#x2F;&#x2F; +005ch - 文件的子系统    WORD    DllCharacteristics;    &#x2F;&#x2F; +005eh - DLL文件特性    DWORD   SizeOfStackReserve;    &#x2F;&#x2F; +0060h - 初始化时的栈大小    DWORD   SizeOfStackCommit;     &#x2F;&#x2F; +0064h - 初始化时实际提交的栈大小    DWORD   SizeOfHeapReserve;     &#x2F;&#x2F; +0068h - 初始化时保留的堆大小    DWORD   SizeOfHeapCommit;      &#x2F;&#x2F; +006ch - 初始化时实际提交的堆大小&#x2F;&#x2F;ULONGLONG SizeOfStackReserve;&#x2F;&#x2F;ULONGLONG SizeOfStackCommit;&#x2F;&#x2F;ULONGLONG SizeOfHeapReserve;&#x2F;&#x2F;ULONGLONG SizeOfHeapCommit;    DWORD   LoaderFlags;           &#x2F;&#x2F; +0070h - 与调试有关    DWORD   NumberOfRvaAndSizes;   &#x2F;&#x2F; +0074h - 下面的数据目录结构数量    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];    &#x2F;&#x2F; +0078h - 数据目录&#125; IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="结构体-image_data_directory"><a class="markdownIt-Anchor" href="#结构体-image_data_directory"></a> 结构体 IMAGE_DATA_DIRECTORY</h5><p><em>IMAGE_DATA_DIRECTORY</em> 定义如下</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_DATA_DIRECTORY &#123;DWORD   VirtualAddress; &#x2F;&#x2F; +0000h - 数据的起始RVADWORD   Size;           &#x2F;&#x2F; +0004h - 数据块的长度，非准确值&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字段解析-3"><a class="markdownIt-Anchor" href="#字段解析-3"></a> 字段解析</h4><ol><li><code>Magic</code>：决定 <em>IMAGE_OPTIONAL_HEADER</em> 版本<table><thead><tr><th>Magic</th><th>版本</th></tr></thead><tbody><tr><td>0x010B</td><td>PE32</td></tr><tr><td>0x020B</td><td>PE32+</td></tr></tbody></table></li><li><code>AddressOfEntryPoint</code>：程序执行的入口，该地址是一个 RVA，指向执行的第一条代码</li><li><code>ImageBase</code>：默认加载基址</li><li><code>BaseOfCode</code>：代码节的起始位置</li><li><code>BaseOfData</code>：只存在于 <strong>32位</strong> 版本，很多情况下可以为 0</li><li><code>SectionAlignment</code>：内存中的块对齐值，一般为 <code>0x1000</code><em>(4096)</em> 字节，即 <code>4KiB</code></li><li><code>FileAlignment</code>：文件中的块对齐值，一般为 <code>0x200</code><em>(512)</em> 字节或 <code>0x1000</code><em>(4096)</em> 字节</li><li><code>SizeOfHeaders</code>：整个头部即DOS头、PE头以及节表总大小，该值按照 <code>FileAlignment</code> 对齐</li><li><code>Subsystem</code><ul><li>0    未知子系统</li><li><strong>1设备驱动程序和Native Windows进程</strong></li><li><strong>2图形用户界面子系统，即一般程序</strong></li><li><strong>3控制台子系统</strong></li><li>7     Posix 字符模式子系统</li><li>9    Windows CE</li><li>10    可扩展固件接口（EFI）应用程序</li><li>11    带引导服务的 EFI 驱动程序</li><li>12    带运行时服务的 EFI 驱动程序</li><li>13    EFI ROM 镜像</li><li>14    XBOX 子系统</li></ul></li><li><code>DllCharacteristics</code><ul><li>1保留，必须为 0</li><li>2保留，必须为 0</li><li>3保留，必须为 0</li><li>4保留，必须为 0</li><li>5官方文档缺失</li><li>6官方文档缺失</li><li>7DLL 可以在加载时被重定位</li><li>8强制进行代码完整性校验</li><li>9镜像兼容于 NX</li><li>10 可以隔离，但并不隔离此镜像</li><li>11 不使用结构化异常（SE）处理</li><li>12 不绑定镜像</li><li>13 保留，必须为 0</li><li>14 WDM 驱动程序</li><li>15 官方文档缺失</li><li>16 可以用于终端服务器</li></ul></li><li><code>NumberOfRvaAndSizes</code>：数据目录项个数，宏定义如下<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>DataDirectory</code><ul><li>该数组定义了 PE 文件中出现的所有不同类型的数据目录信息</li><li>数据目录中定义的数据类型有 16 种，下标从 0 开始</li><li>下标说明<ul><li>0 <strong>导出表</strong> 地址下标</li><li>1 <strong>导入表</strong> 地址下标</li><li>2 <strong>资源表</strong> 地址下标</li><li>3 异常表地址下标</li><li>4 属性证书数据地址下标</li><li>5 基地址 <strong>重定位</strong> 表地址下标</li><li>6 调试信息地址索引</li><li>7 预留为 0</li><li>8 指向全局指针寄存器的值</li><li>9 线程局部存储索引</li><li>10 加载配置表索引</li><li>11 绑定导入表索引</li><li>12 <strong>导入函数</strong> 地址表索引</li><li>13 延迟导入表索引</li><li>14 CLR 运行时头部数据索引</li><li>15 系统保留</li></ul></li></ul></li></ol><h2 id="directory-section"><a class="markdownIt-Anchor" href="#directory-section"></a> Directory Section</h2><ul><li>在 <em>IMAGE_OPTIONAL_HEADER</em> 之后，由多个节表项(<em>IMAGE_SECTION_HEADER</em>)组成</li><li>每个节表项记录了 PE 中与某个特定的节有关的信息，如节的属性、节的大小、在文件和内存中的起始位置等</li><li>节表中节的数量由 <em>IMAGE_FILE_HEADER.NumberOfSection</em> 字段来定义</li><li>结构体大小定义如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_SIZEOF_SECTION_HEADER    40<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="常见命名"><a class="markdownIt-Anchor" href="#常见命名"></a> 常见命名</h3><table><thead><tr><th>节区名称</th><th>描述</th></tr></thead><tbody><tr><td><code>.text</code></td><td>包含 CPU 指令，唯一包含代码的节</td></tr><tr><td><code>.data</code></td><td>可 <strong>读写</strong> 的数据，存放全局变量或静态变量</td></tr><tr><td><code>.rdata</code></td><td><strong>全局</strong> 可访问的 <strong>只读</strong> 数据</td></tr><tr><td><code>.rodata</code></td><td></td></tr><tr><td><code>.idata</code></td><td>显示和存储导入函数，如果不存在则存放于 <code>.rdata</code></td></tr><tr><td><code>.edata</code></td><td>显示和存储导出数据，如果不存在则存放于 <code>.rdata</code></td></tr><tr><td><code>.pdata</code></td><td>只存在于 64位 可执行文件，处理异常信息</td></tr><tr><td><code>.rsrc</code></td><td>存放程序用到的所有资源，如图表，菜单等</td></tr><tr><td><code>.reloc</code></td><td>包含重定位信息</td></tr><tr><td><code>.bss</code></td><td>未初始化数据区</td></tr><tr><td><code>.crt</code></td><td>用于支持C++运行时库所添加的数据</td></tr><tr><td><code>.tls</code></td><td>存储线程局部变量</td></tr><tr><td><code>.sdata</code></td><td>包含相对于可被全局指针定位的可读写数据</td></tr><tr><td><code>.srdata</code></td><td>包含相对于可被全局指针定位的只读数据</td></tr><tr><td><code>.debug$S</code></td><td>包含OBJ文件中的Codeview格式符号</td></tr><tr><td><code>.debug$T</code></td><td>包含OBJ文件中的Codeview格式类型的符号</td></tr><tr><td><code>.debug$P</code></td><td>包含使用预编译头时的一些信息</td></tr><tr><td><code>.drectve</code></td><td>包含编译时的一些链接命令</td></tr><tr><td><code>.comment</code></td><td></td></tr><tr><td><code>.didat</code></td><td>包含延迟装入的数据</td></tr></tbody></table><h3 id="结构体-image_section_header"><a class="markdownIt-Anchor" href="#结构体-image_section_header"></a> 结构体 IMAGE_SECTION_HEADER</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_SIZEOF_SHORT_NAME    8typedef struct _IMAGE_SECTION_HEADER &#123;    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; &#x2F;&#x2F; +0000h - 节名    union &#123;            DWORD   PhysicalAddress;            DWORD   VirtualSize;    &#125; Misc;                        &#x2F;&#x2F; +0008h - 节区的尺寸    DWORD   VirtualAddress;        &#x2F;&#x2F; +000ch - 节区的RVA地址    DWORD   SizeOfRawData;         &#x2F;&#x2F; +0010h - 在文件中对齐后的大小    DWORD   PointerToRawData;      &#x2F;&#x2F; +0014h - 在文件中的偏移    DWORD   PointerToRelocations;  &#x2F;&#x2F; +0018h - 在OBJ文件中使用    DWORD   PointerToLinenumbers;  &#x2F;&#x2F; +001ch - 行号表的位置（调试用）    WORD    NumberOfRelocations;   &#x2F;&#x2F; +0020h - 在OBJ文件中使用    WORD    NumberOfLinenumbers;   &#x2F;&#x2F; +0022h - 行号表中行号的数量    DWORD   Characteristics;       &#x2F;&#x2F; +0024h - 节的属性&#125; IMAGE_SECTION_HEADER，*PIMAGE_SECTION_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字段解析-4"><a class="markdownIt-Anchor" href="#字段解析-4"></a> 字段解析</h3><ol><li><code>Name</code>：节表项名称，长度为 8 的 ASCII 码字符，常用 <code>.</code> 起始命名</li><li><code>Characteristics</code><ul><li>1、2、3、4、5 已经废除</li><li><strong>6 此节包含可执行代码 <code>.text</code></strong></li><li><strong>7 此节包含已初始化的数据 <code>.data</code></strong></li><li><strong>8 此节包含未初始化的数据 <code>.bss</code></strong></li><li>9、10、11、12、13、14、15 已经废除</li><li>16 此节包含通过全局指针（GP）来引用的数据</li><li>17、18、19、20、21、22、23、24 已经废除</li><li>25 此节包含扩展的重定位信</li><li>26 此节可以在需要时被丢弃</li><li>27 此节不能被缓存</li><li>28 此节不能被交换到页面文件中</li><li>29 此节可以在内存中共享</li><li><strong>30 此节可以作为代码执行</strong></li><li><strong>31 此节可读</strong></li><li><strong>32 此节可写</strong></li></ul></li></ol><h2 id="数据区"><a class="markdownIt-Anchor" href="#数据区"></a> 数据区</h2><p>有一些 PE 文件格式相关的结构体不在 PE 头部，而是分散在各个数据节中，位置由 <code>IMAGE_OPTIONAL_HEADER.DataDirtory</code> 数组给出<br />保存了导出表、导入表、重定位表等结构</p><h3 id="导出表"><a class="markdownIt-Anchor" href="#导出表"></a> 导出表</h3><ul><li>数据目录第 <strong>一</strong> 项</li><li>导出表即导出函数表，调用的 API 函数是由 DLL 文件导出的函数</li><li>通常导出表只存在于 DLL 文件</li></ul><h4 id="导出函数"><a class="markdownIt-Anchor" href="#导出函数"></a> 导出函数</h4><h5 id="导出函数的定义"><a class="markdownIt-Anchor" href="#导出函数的定义"></a> 导出函数的定义</h5><ol><li>直接在函数定义时导出</li><li>通过定义 <code>.def</code> 文件导出</li></ol><h5 id="导出函数的调用"><a class="markdownIt-Anchor" href="#导出函数的调用"></a> 导出函数的调用</h5><ol><li>隐式调用，程序编译时生成导入表</li><li>显示调用，通过 <em>LoadLibrary</em> 函数和 <em>GetProcAddress</em> 函数调用</li></ol><h4 id="结构体-image_export_directory"><a class="markdownIt-Anchor" href="#结构体-image_export_directory"></a> 结构体 IMAGE_EXPORT_DIRECTORY</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;    DWORD   Characteristics;       &#x2F;&#x2F; 保留值，必须0    DWORD   TimeDateStamp;         &#x2F;&#x2F; 时间戳    WORD    MajorVersion;          &#x2F;&#x2F; 主版本号，默认0    WORD    MinorVersion;          &#x2F;&#x2F; 次版本号，默认0    DWORD   Name;                  &#x2F;&#x2F; PE文件的名称    DWORD   Base;                  &#x2F;&#x2F; 序号基数    DWORD   NumberOfFunctions;     &#x2F;&#x2F; 导出函数的数量    DWORD   NumberOfNames;         &#x2F;&#x2F; 以函数名称导出的函数的数量    DWORD   AddressOfFunctions;    &#x2F;&#x2F; 导出函数地址表的RVA    DWORD   AddressOfNames;        &#x2F;&#x2F; 导出名称指针表的RVA    DWORD   AddressOfNameOrdinals; &#x2F;&#x2F; 序号表的RVA&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字段解析-5"><a class="markdownIt-Anchor" href="#字段解析-5"></a> 字段解析</h4><ol><li><code>TimeDateStamp</code>：绑定导入表的时间戳会和 DLL 的时间戳对比，不相同则不生效</li><li><code>Name</code>：指向该文件名 ASCII 码字符串的 RVA</li><li><code>Base</code>：映像中导出符号的起始序数值，指定导出地址表的起始序数值，通常为 1</li><li><code>AddressOfNames</code>：保存导出名称指针表的 RVA，该表数量是 <code>NumberOfNames</code> 的值</li><li><code>AddressOfNameOrdinals</code>：导出序数表的 RVA，该表数量是 <code>NumberOfNames</code> 的值。此处的值是索引值，加上 <code>Base</code> 才是真正的序号</li></ol><h3 id="导入表"><a class="markdownIt-Anchor" href="#导入表"></a> 导入表</h3><ul><li>数据目录第 <strong>二</strong> 项</li><li>在 PE 文件运行时，需要别的 PE 文件给予的支持。因此导入表存储的是从其他文件导入过来的函数名，序号。在加载到内存之后，会存储这些函数的地址</li><li>由于一个 PE 文件可能会需要多个 PE 文件的支持，所以导入表结构一般有多个，即导入表是一个 <strong>结构体数组</strong> ，以一个全零元素为结尾，每一个数组的元素，代表一个 PE 文件的导入信息</li></ul><h4 id="绑定导入表"><a class="markdownIt-Anchor" href="#绑定导入表"></a> 绑定导入表</h4><ul><li>使用绑定导入表中的地址，需要有两个前提<ol><li>装载地址与 <code>IMAGE_OPTIONAL_HEADER.ImageBase</code> 相同</li><li>DLL 提供的函数地址没有变化</li></ol></li><li>结构体定义  <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR &#123;    WORD    TimeDateStamp;    WORD    OffsetMosuleName;    WORD    NumberOfModuleForwarderRefs;&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>字段解析<ol><li><code>OffsetMosuleName</code>：绑定模块的名称，该值是一个以第一个 <em>IMAGE_BOUND_IMPORT_DESCRIPTOR</em> 为起始地址的偏移</li><li><code>NumberOfModuleForwarderRefs</code>：</li></ol></li><li>PE 文件装载时，Windows 需要根据导入表的模块名称和函数名称装载相应模块，得到导入函数的地址并填充导入地址表，绑定地址表则直接将导入函数写入 PE 文件</li></ul><h4 id="结构体-image_import_descriptor"><a class="markdownIt-Anchor" href="#结构体-image_import_descriptor"></a> 结构体 IMAGE_IMPORT_DESCRIPTOR</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD   Characteristics;        DWORD   OriginalFirstThunk; &#x2F;&#x2F; 指向一个 INT 的相对虚拟地址 RVA    &#125; DUMMYUNIONNAME;    DWORD   TimeDateStamp;          &#x2F;&#x2F; 时间标志    DWORD   ForwarderChain;         &#x2F;&#x2F; 转发机制用到    DWORD   Name;                   &#x2F;&#x2F; 导入的PE文件的名字的相对虚拟地址RVA    DWORD   FirstThunk;             &#x2F;&#x2F; IAT，指向一个结构体数组 RVA&#125; IMAGE_IMPORT_DESCRIPTOR， *PIMAGE_IMPORT_DESCRIPTOR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字段解析-6"><a class="markdownIt-Anchor" href="#字段解析-6"></a> 字段解析</h4><ol><li><code>OriginalFirstThunk</code>：保存了指向导入函数名称（序号）的 RVA 表，该表是一个 <code>IMAGE_THUNK_DATA</code> 结构体，定义如下 <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString;        DWORD Function;       &#x2F;&#x2F;导入函数的地址        DWORD Ordinal;        DWORD AddressOfData;    &#125; u1;  &#125; IMAGE_THUNK_DATA32;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>该结构体分 <strong>32位</strong> 和 <strong>64位</strong> 版本</li><li>union 四个字段占用相同空间<ol><li><code>Ordinal</code>：导入函数的序号，<em>IMAGE_THUNK_DATA</em> 最高位为 1 时有效</li><li><code>AddressOfData</code>：指向 <em>IMAGE_IMPORT_BY_NAME</em> 结构体的 RVA，当 <em>IMAGE_THUNK_DATA</em> 最高位不为 1 时有效<blockquote><p>IMAGE_IMPORT_BY_NAME 结构体定义如下</p></blockquote> <pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_IMPORT_BY_NAME &#123;    WORD    Hint;    CHAR   Name[1]; &#x2F;&#x2F; 表示导入函数名称，ASCII 码，以 NULL 结尾，长度 1 字节&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><em>IMAGE_IMPORT_BY_NAME</em> 结构体可以了解导入函数是通过 <strong>序号</strong> 还是 <strong>名称</strong> 导入；</p><ul><li>序号导入，则序号可以在 <em>IMAGE_THUNK_DATA</em> 中获得</li><li>名称导入，则借助 <em>IMAGE_IMPORT_BY_NAME</em> 得到导入函数名称</li></ul></blockquote></li></ol></li></ul></li><li><code>FirstThunk</code>：装载内存前，保存了指向导入地址表的 RVA 表，与 <code>OriginalFirstThunk</code> 相同，装载内存后则写入 <strong>导入函数的实际地址</strong></li></ol><h3 id="重定位表"><a class="markdownIt-Anchor" href="#重定位表"></a> 重定位表</h3><p>建议装载地址：<code>IMAGE_OPTIONAL_HEADER.ImageBase</code> 字段是建议装载地址</p><ul><li>数据目录第 <strong>六</strong> 项</li><li>通过第五项进行定位，下标从 0 开始，索引定位如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 &#x2F;&#x2F; Base Relocation Table<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>重定位表由多个 <em>IMAGE_BASE_RELOCATION</em> 组合而成，且以一个全 0 的结构体结束</li><li>重定位地址修正：<strong>实际装载地址</strong> 减去 <strong>建议装载地址</strong>，用得出的 <strong>差值</strong> 加上用建议装载地址得出的装载地址</li></ul><h4 id="结构体-image_base_relocation"><a class="markdownIt-Anchor" href="#结构体-image_base_relocation"></a> 结构体 IMAGE_BASE_RELOCATION</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _IMAGE_BASE_RELOCATION &#123;    DWORD   VirtualAddress; &#x2F;&#x2F; 重定位数据的 RVA    DWORD   SizeOfBlock;    &#x2F;&#x2F; 结构体的大小    WORD    TypeOffset[1];  &#x2F;&#x2F; 偏移&#125; IMAGE_BASE_RELOCATION;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字段解析-7"><a class="markdownIt-Anchor" href="#字段解析-7"></a> 字段解析</h4><ol><li><code>SizeOfBlock</code>：当前区段重定位结构的大小，包括重定位数据，<em>IMAGE_BASE_RELOCATION</em> 结构体大小是 8 字节，即该值 <code>8 BYTE + n * WORD</code></li><li><code>TypeOffset</code>：高 4 位表示类型，低 12 位表示区段内需要重定位的 RVA 值<ul><li><code>TypeOffset</code> 类型取值定义如下  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define IMAGE_REL_BASED_ABSOLUTE        0#define IMAGE_REL_BASED_HIGH            1#define IMAGE_REL_BASED_LOW             2#define IMAGE_REL_BASED_HIGHLOW         3#define IMAGE_REL_BASED_HIGHADJ         4#define IMAGE_REL_BASED_MIPS_JMPADDR    5#define IMAGE_REL_BASED_MIPS_JMPADDR    9#define IMAGE_REL_BASED_IA64_IMM64      9#define IMAGE_REL_BASED_DIR64           10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>Win32 下，所有重定位类型都是 <em>IMAGE_REL_BASED_HIGHLOW</em></li><li><code>TypeOffset</code> 的数量：整个区段重定位结构的大小(<code>SizeOfBlock</code>)减去 8 字节，再除以 2 (<code>BYTE</code>)</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 参考 </tag>
            
            <tag> PE </tag>
            
            <tag> 文件格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 部署</title>
      <link href="2018/11/ssh-bu-shu/"/>
      <url>2018/11/ssh-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="ssh-概述"><a class="markdownIt-Anchor" href="#ssh-概述"></a> SSH 概述</h2><p>SSH，<a href="https://en.wikipedia.org/wiki/Secure_Shell" title="Wiki">Secure Shell</a>，是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。该协议由 <em>IETF</em> 的网络工作小组（Network Working Group）制定。</p><p>SSH 是 Telnet 和非安全 shell 的替代品。Telnet 和 rsh、rexec 等协议采用明文传输，使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。SSH 旨在保证非安全网络环境（例如互联网）中信息加密完整可靠。</p><p>众所周知，SSH 最常见的用途就是远程登录系统。</p><h2 id="openssh"><a class="markdownIt-Anchor" href="#openssh"></a> OpenSSH</h2><blockquote><p>OpenSSH（<a href="https://en.wikipedia.org/wiki/OpenSSH" title="Wiki">OpenBSD Secure Shell</a>）是 OpenBSD 的子项目。它是取代由 SSH Communications Security 所提供的商用版本的开放源代码方案。</p></blockquote><p><a href="https://www.openssh.com" title="主页">OpenSSH</a> 是 SSH 的一个开源实现，提供了服务端后台程序和客户端工具。</p><p>该项目主要由以下部分组成：</p><ul><li>远程操作工具：<ul><li>ssh</li><li>scp</li><li>sftp</li></ul></li><li>秘钥管理工具：<ul><li>ssh-add</li><li>ssh-keysign</li><li>ssh-keyscan</li><li>ssh-keygen</li></ul></li><li>服务器端程序：<ul><li>sshd</li><li>sftp-server</li><li>ssh-agent</li></ul></li></ul><p>其中比较常见的，ssh 是远程登陆的客户端，macOS 和大多数 Linux 发行版默认集成，Windows 从 Win10 1809 开始集成（以前版本则需要一些管理工具，如 Putty、Xshell、MobaXterm 等） ，sshd 是服务器端的守护进程，ssh-keygen 用于生成秘钥。</p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>在服务器部署 OpenSSH 守护进程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> openssh-server     <span class="token comment"># Ubuntu</span>$ yum <span class="token function">install</span> openssh-server     <span class="token comment"># CentOS</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装完毕可以在本机测试是否连通：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ssh</span> localhost<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">service</span> sshd start      <span class="token comment"># Ubuntu、CentOS</span>$ /etc/init.d/ssh start   <span class="token comment"># Debian</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="重启"><a class="markdownIt-Anchor" href="#重启"></a> 重启</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">service</span> <span class="token function">ssh</span> restart     <span class="token comment"># Ubuntu、CentOS</span>$ /etc/init.d/ssh restart <span class="token comment"># Debian</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>服务器配置文件路径：<code>/etc/ssh/sshd_config</code>。</p><p>部分说明如下：</p><pre class="line-numbers language-none"><code class="language-none"># StrictHostKeyChecking ask# IdentityFile ~&#x2F;.ssh&#x2F;id_rsa# IdentityFile ~&#x2F;.ssh&#x2F;id_dsa# IdentityFile ~&#x2F;.ssh&#x2F;id_ecdsa# IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519# Port 22# Protocol 2# ListenAddress 0.0.0.0   绑定的 IP 地址# ServerKeyBits 1024      服务器秘钥位数# PermittedRootLogin yes  允许 root 登录# StrictModes yes         接受登录请求之前检查用户主目录# Tunnel no# TunnelDevice any:any# PrintMod yes  登录时显示 &#x2F;etc&#x2F;motd 信息# RSAAuthentication yes 允许 RSA 验证# PermitEmptyPasswords no# AllowUsers    允许连接的用户# AllowGroups   允许连接的群组# DenyUsers     拒绝连接的用户# Denygroups    拒绝连接的群组# PermitLocalCommand no# VisualHostKey no# RekeyLimit 1G 1h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第一次登录"><a class="markdownIt-Anchor" href="#第一次登录"></a> 第一次登录</h2><p>使用口令登录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ssh</span> <span class="token operator">&lt;</span>user<span class="token operator">></span>@<span class="token operator">&lt;</span>host<span class="token operator">></span> -p <span class="token punctuation">[</span>port<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一次登录，需要验证公钥指纹以权衡风险，会遇到如下提示：</p><pre class="line-numbers language-none"><code class="language-none">The authenticity of host &#39;host (12.18.429.97)&#39; can&#39;t be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:33:16:58:4d.Are you sure you want to continue connecting (yes&#x2F;no)?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>确认后输入 <code>yes</code> 即可登录服务器账户。</p><h3 id="公钥文件"><a class="markdownIt-Anchor" href="#公钥文件"></a> 公钥文件</h3><p>确认提示后会将所登录的主机写入一个文件，记录可信赖的 <strong>远程主机</strong> 的公钥，该文件路径如下：</p><ul><li>当前用户：<code>$HOME/.ssh/known_hosts</code></li><li>系统：<code>/etc/ssh/ssh_known_hosts</code></li></ul><p>实际上 <code>ssh</code> 文件夹下，有以下文件：</p><pre class="line-numbers language-none"><code class="language-none">id_rsaid_rsa.pubknown_hosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>id_rsa</code> 和 <code>id_rsa.pub</code> 分别为用户主机的私钥和公钥。</p><h3 id="公钥登陆"><a class="markdownIt-Anchor" href="#公钥登陆"></a> 公钥登陆</h3><p>用户将自己的公钥储存在远程主机上，登录的时候，远程主机向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密</p><ol><li>生成用户公钥 <code>ssh-keygen</code></li><li>运行结束以后，<code>$HOME/.ssh/</code> 目录下会生成两个文件 <code>id_rsa.pub</code> 和 <code>id_rsa</code></li><li>前者是公钥，后者是私钥</li><li>用 <code>ssh-copy-id</code> 将公钥传送到远程主机上</li><li>检查远程主机的 <code>/etc/ssh/sshd_config</code> <pre class="line-numbers language-none"><code class="language-none">RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="登录选项"><a class="markdownIt-Anchor" href="#登录选项"></a> 登录选项</h2><p>常用登录选项：</p><ul><li><code>-N</code>：只连接远程主机，不打开远程 shell</li><li><code>-T</code>：不分配 TTY</li><li><code>-f</code>：后台运行</li><li><code>-p &lt;端口&gt;</code>：指定端口号</li><li><code>-l &lt;登录名&gt;</code>：指定登录名</li><li><code>-q</code>：安静模式</li><li><code>-v</code>：详细模式</li><li><code>-b &lt;绑定地址:&gt;</code>：指定绑定地址作为源地址</li><li><code>-g</code>：远程主机在本地的转发端口</li><li><code>-4</code>：只使用 ipv4</li><li><code>-6</code>：只使用 ipv6</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
